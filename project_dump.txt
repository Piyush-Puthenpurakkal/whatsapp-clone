

--- .env ---
SECRET_KEY=django-insecure-temp-key
DEBUG=True

# MongoDB
MONGO_URI=mongodb://localhost:27017
MONGO_DB_NAME=videochat



--- .gitignore ---
# Byte-compiled / optimized / DLL files
__pycache__/
*.pyc
*.pyd
*.pyo
*.egg-info/
.Python
build/
develop-eggs/
dist/
eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg
.env

# OS-specific files
.DS_Store
.Trashes
Thumbs.db

# Database
*.sqlite3
*.db
*.rdb

# Media files
media/

# Static files
static_root/

# IDE-specific files
.vscode/
.idea/

# Virtual environment
venv/
env/

# Logs
*.log



--- dump.rdb ---
<< Could not read file: 'utf-8' codec can't decode byte 0xfa in position 9: invalid start byte >>


--- dump_project.py ---
import os

# set your project path here
PROJECT_DIR = "E:/Piyush/Python Projects/videochat_app"
OUTPUT_FILE = "project_dump.txt"

def dump_project_to_txt(project_dir, output_file):
    with open(output_file, "w", encoding="utf-8") as out:
        for root, dirs, files in os.walk(project_dir):
            for file in files:
                # skip virtual env, cache, db files, etc.
                if file.endswith((".pyc", ".pyo", ".db", ".sqlite3", ".exe")):
                    continue
                if "venv" in root or "__pycache__" in root:
                    continue

                filepath = os.path.join(root, file)
                try:
                    with open(filepath, "r", encoding="utf-8") as f:
                        code = f.read()
                except Exception as e:
                    code = f"<< Could not read file: {e} >>"

                # write header + content
                out.write(f"\n\n--- {filepath.replace(project_dir, '').lstrip(os.sep)} ---\n")
                out.write(code)
                out.write("\n")
    print(f"✅ Project dumped into {output_file}")

# run it
dump_project_to_txt(PROJECT_DIR, OUTPUT_FILE)



--- manage.py ---
#!/usr/bin/env python
import os
import sys

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'videochat.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError("Couldn't import Django.") from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()



--- project_dump.txt ---



--- requirements.txt ---
Django>=4.2
channels>=4.0
daphne>=4.0
djangorestframework
djangorestframework-simplejwt
django-ratelimit
pymongo
channels_redis
python-dotenv
django-redis
django-webpush



--- todo.txt ---
All required packages are installed in a virtual environment, and the server is already running. I am also already logged in, so authentication is not an issue.

Currently, new messages only appear after refreshing the page — I want them to update in real-time without refreshing.

id - admin
pass - adminpass123

id - piyushraj98
pass - userpass123

id - piyush98
pass - userpass123


--- videochat_app.txt ---
_______________________________________________________________________________________________
videochat_app/accounts/admin.py
_______________________________________________________________________________________________
videochat_app/accounts/apps.py

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'
_______________________________________________________________________________________________
videochat_app/accounts/forms.py

from django import forms
from django.contrib.auth.models import User
from django.contrib.auth.forms import UserCreationForm

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(required=True)

    class Meta:
        model = User
        fields = ("username", "email", "password1", "password2")

    def save(self, commit=True):
        user = super().save(commit=False)
        user.email = self.cleaned_data["email"]
        if commit:
            user.save()
        return user
_______________________________________________________________________________________________
videochat_app/accounts/models.py
_______________________________________________________________________________________________
videochat_app/accounts/tests.py
_______________________________________________________________________________________________
videochat_app/accounts/urls.py

from django.urls import path
from .views import SignUpView

urlpatterns = [
    path('signup/', SignUpView.as_view(), name='signup'),
]
_______________________________________________________________________________________________
videochat_app/accounts/views.py

from django.urls import reverse_lazy
from django.views import generic
from django.contrib import messages
from chat.mongo import get_db
from datetime import datetime
from .forms import CustomUserCreationForm

class SignUpView(generic.CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/signup.html'

    def form_valid(self, form):
        response = super().form_valid(form)
        try:
            db = get_db()
            db.users.insert_one({
                "username": self.object.username,
                "email": self.object.email,
                "date_joined": datetime.utcnow()
            })
            messages.success(self.request, "Account created successfully!")
        except Exception as e:
            messages.warning(self.request, f"Account created, but failed to save in MongoDB: {e}")
        return response
_______________________________________________________________________________________________
videochat_app/chat/templates/chat/base.html

{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>{% block title %}VideoChat{% endblock %}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="{% static 'css/app.css' %}" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    />
    {% block extra_head %}{% endblock %}
  </head>

  <body>
    <!-- TOPBAR -->
    <header class="topbar">
      <div class="topbar__left">
        <a href="/" class="brand">WhatsApp Clone</a>
      </div>
      <div class="topbar__right">
        <span class="whoami"
          >Hi, <strong>{{ request.user.username }}</strong></span
        >
        <a class="btn btn-ghost" href="{% url 'notifications' %}"
          ><i class="fas fa-bell"></i
        ></a>
        <a class="btn btn-ghost" href="/"><i class="fas fa-home"></i></a>
        <!-- Safe logout via POST -->
        <form
          id="logoutForm"
          method="post"
          action="{% url 'logout' %}"
          class="logout-form"
        >
          {% csrf_token %}
          <button type="submit" class="btn btn-ghost">
            <i class="fas fa-sign-out-alt"></i>
          </button>
        </form>
      </div>
    </header>

    <!-- WORKSPACE -->
    <main class="workspace">
      <aside class="pane pane--left">
        <div class="sidebar">
          <div class="sidebar__header">
            <div class="avatar">{{ request.user.username|first|upper }}</div>
            <div class="actions">
              <button class="btn btn-ghost">
                <i class="fas fa-circle-notch"></i>
              </button>
              <button class="btn btn-ghost">
                <i class="fas fa-comment-alt"></i>
              </button>
              <button class="btn btn-ghost">
                <i class="fas fa-ellipsis-v"></i>
              </button>
            </div>
          </div>
          <div class="sidebar__search">
            <input type="text" placeholder="Search or start new chat" />
          </div>
          <ul class="chat-list">
            {% block sidebar %}{% endblock %}
          </ul>
        </div>
      </aside>
      <section class="pane pane--right">
        {% block content %}
        <div class="empty-state">
          <h2>Welcome to WhatsApp Clone</h2>
          <p>Click on a chat to start messaging or start a new one.</p>
        </div>
        {% endblock %}
      </section>
    </main>

    <!-- POPUPS -->
    <div id="popup-message" class="popup">
      <h4>New Message</h4>
      <p id="popup-message-text"></p>
      <div class="actions">
        <button class="btn btn-ghost" onclick="hidePopup('popup-message')">
          Close
        </button>
      </div>
    </div>
    <div id="popup-call" class="popup">
      <h4>Incoming Call</h4>
      <p id="popup-call-text"></p>
      <div class="actions">
        <button id="btnAcceptCall" class="btn btn-primary">
          <i class="fas fa-phone"></i> Accept
        </button>
        <button id="btnRejectCall" class="btn btn-danger">
          <i class="fas fa-phone-slash"></i> Reject
        </button>
      </div>
    </div>

    <script>
      // popup helpers
      function showPopup(id, text) {
        const t = document.getElementById(id + "-text");
        if (t) t.innerText = text || "";
        document.getElementById(id).style.display = "block";
      }
      function hidePopup(id) {
        document.getElementById(id).style.display = "none";
      }

      // Define APP_CONTEXT for global scripts
      window.APP_CONTEXT = {
        me: "{{ request.user.username|escapejs }}",
        // wsUrl will be defined dynamically in chat.js or overridden in room.html
      };
    </script>
    <script src="{% static 'js/global-call-manager.js' %}"></script>
    <script src="{% static 'js/chat.js' %}"></script>
    {% block scripts %}{% endblock %}
    <script>
      // Event listeners for global call popup
      document.getElementById("btnAcceptCall").addEventListener("click", () => {
        window.GlobalCallManager.acceptCall();
      });

      document.getElementById("btnRejectCall").addEventListener("click", () => {
        window.GlobalCallManager.rejectCall();
      });
    </script>
  </body>
</html>
_______________________________________________________________________________________________
videochat_app/chat/templates/chat/home.html

{% extends "chat/base.html" %} {% block title %}Home{% endblock %}
{% block sidebar %}
<ul id="sidebarUsers">
  {% if users %} {% for u in users %}
  <li class="chat-item" data-username="{{ u.username }}">
    <a class="chat-item__link" href="{% url 'room_with_user' u.username %}">
      <div class="chat-item__avatar">{{ u.username|first|upper }}</div>
      <div class="chat-item__meta">
        <div class="chat-item__top">
          <span class="chat-item__name">@{{ u.username }}</span>
          <span class="user-status"> (Offline)</span> {# Initial status, will be
          updated by JS #}
          <span class="chat-item__time"></span>
        </div>
        <div class="chat-item__last">Start a new chat</div>
      </div>
    </a>
  </li>
  {% endfor %} {% else %}
  <li class="chat-item--empty">No other users yet.</li>
  {% endif %}
</ul>
{% endblock %} {% block content %}
<div class="empty-state">
  <h2>Welcome to WhatsApp Clone</h2>
  <p>Click on a chat to start messaging or start a new one.</p>
</div>
{% endblock %}
_______________________________________________________________________________________________
videochat_app/chat/templates/chat/notifications.html

{% extends "chat/base.html" %}
{% block title %}Notifications{% endblock %}

{% block content %}
<div class="card">
  <h2>Notifications</h2>
  <ul>
    {% for log in logs %}
    <li style="margin:6px 0;">
      <strong>{{ log.sender }}</strong>
      {% if log.type == "chat" %}
      sent a message: “{{ log.message }}”
      {% elif log.type == "offer" %}
      started a call
      {% elif log.type == "answer" %}
      answered a call
      {% elif log.type == "ice" %}
      exchanged network info
      {% else %}
      {{ log.type }} {{ log.message }}
      {% endif %}
      <small style="color:#666;"> — {{ log.timestamp }}</small>
    </li>
    {% empty %}
    <li>No notifications yet.</li>
    {% endfor %}
  </ul>
</div>
{% endblock %}
_______________________________________________________________________________________________
videochat_app/chat/templates/chat/room.html

{% extends "chat/base.html" %} {% load static %} {% block title %}Chat with @{{ peer.username }} {% endblock %}
{% block sidebar %}
<ul id="sidebarUsers">
  {% for u in users %}
  <li class="chat-item {% if u.username == peer.username %}is-active{% endif %}" data-username="{{ u.username }}">
    <a class="chat-item__link" href="{% url 'room_with_user' u.username %}">
      <div class="chat-item__avatar">{{ u.username|first|upper }}</div>
      <div class="chat-item__meta">
        <div class="chat-item__top">
          <span class="chat-item__name">@{{ u.username }}</span>
          <span class="user-status"> (Offline)</span> {# Initial status, will be
          updated by JS #}
          <span class="chat-item__time"></span>
        </div>
        <div class="chat-item__last"></div>
      </div>
    </a>
  </li>
  {% empty %}
  <li class="chat-item--empty">No other users yet.</li>
  {% endfor %}
</ul>
{% endblock %} {% block content %}
<div class="chat">
  <div class="chat__header">
    <div class="peer">
      <div class="peer__avatar">{{ peer.username|first|upper }}</div>
      <div class="peer__info">
        <div class="peer__name">@{{ peer.username }}</div>
        <div class="peer__status" id="chatHeaderStatus" data-peer-username="{{ peer.username }}">
          Offline
        </div>
        {# Initial status, will be updated by JS #}
      </div>
    </div>
    <div class="actions">
      <button id="btnStartCall" class="btn btn-ghost">
        <i class="fas fa-video"></i>
      </button>
    </div>
  </div>

  <div id="chatBox" class="chat__messages">
    {% for m in history %}
    <div class="msg {% if m.sender == request.user.username %}msg--me{% else %}msg--peer{% endif %}">
      <div class="msg__bubble">
        <div class="msg__text">{{ m.message }}</div>
        <div class="msg__time">{{ m.timestamp|date:"H:i" }}</div>
      </div>
    </div>
    {% empty %}
    <div class="chat__empty">
      <p>Say hello to @{{ peer.username }}!</p>
    </div>
    {% endfor %}
  </div>

  <form id="messageForm" class="composer">
    <button class="composer__btn"><i class="fas fa-smile"></i></button>
    <input id="messageInput" type="text" placeholder="Type a message" required class="composer__input" />
    <button class="composer__btn" type="submit">
      <i class="fas fa-paper-plane"></i>
    </button>
  </form>
</div>

<!-- Global Call Window (Floating/Draggable) -->
<div id="callWindow" class="call-window" style="display: none">
  <div class="call-header">
    <h4 id="callTitle">Video Call with @{{ peer.username }}</h4>
    <div class="call-header-actions">
      <button id="btnMinimizeMaximize" class="btn btn-ghost">
        <i class="fas fa-expand-alt"></i>
      </button>
      <button id="btnEndCall" class="btn btn-danger">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
  <div class="call-body">
    <video id="remoteVideo" autoplay playsinline></video>
    <video id="localVideo" autoplay playsinline muted></video>
    <div class="call-controls">
      <button id="btnToggleMic" class="btn">
        <i class="fas fa-microphone"></i>
      </button>
      <button id="btnToggleCamera" class="btn">
        <i class="fas fa-video"></i>
      </button>
      <button id="btnHangUp" class="btn btn-danger">
        <i class="fas fa-phone-slash"></i>
      </button>
    </div>
  </div>
</div>

<!-- Inline incoming call box (callee only) - Hidden by default, managed by JS -->
<div id="incomingCallBox" class="popup" style="display: none">
  <h4>Incoming Call</h4>
  <p id="incomingCallText"></p>
  <div class="actions">
    <button id="btnAcceptInline" class="btn btn-primary">
      <i class="fas fa-phone"></i> Accept
    </button>
    <button id="btnRejectInline" class="btn btn-danger">
      <i class="fas fa-phone-slash"></i> Reject
    </button>
  </div>
</div>

{% endblock %} {% block scripts %} {{
webrtc_ice_servers|json_script:'webrtc_ice_servers' }}
<script>
  // Extend APP_CONTEXT with room-specific details
  window.APP_CONTEXT.roomName = "{{ room_name }}";
  window.APP_CONTEXT.wsUrl =
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host +
    "/ws/chat/" +
    "{{ room_name }}" +
    "/";
  window.APP_CONTEXT.iceServers = JSON.parse(
    document.getElementById("webrtc_ice_servers").textContent
  );

  // Event listener for the hang up button in the call window
  document.getElementById("btnHangUp").addEventListener("click", () => {
    window.GlobalCallManager.endCall();
  });

  // Event listeners for inline incoming call box
  document.getElementById("btnAcceptInline").addEventListener("click", () => {
    window.GlobalCallManager.acceptCall();
  });

  document.getElementById("btnRejectInline").addEventListener("click", () => {
    window.GlobalCallManager.rejectCall();
  });

  // Update call title when call starts/changes
  window.addEventListener("globalCallStateChange", (event) => {
    const callState = event.detail;
    if (callState && callState.type === "active") {
      document.getElementById(
        "callTitle"
      ).innerText = `Video Call with @${callState.peer}`;
    } else {
      document.getElementById("callTitle").innerText = "Video Call";
    }
  });
</script>
<script src="{% static 'js/webrtc.js' %}"></script>
{% endblock %}
_______________________________________________________________________________________________
videochat_app/chat/templates/registration/login.html

{% extends "base_auth.html" %} {% load static %} {% block title %} Login {% endblock title %} {% block content %}
<h2>Login</h2>
<div class="form-wrapper">
  <form method="post">
    {% csrf_token %} {% if form.errors %}
    <div class="error-box">
      {% for field in form %} {% for error in field.errors %}
      <div>{{ error }}</div>
      {% endfor %} {% endfor %} {% for error in form.non_field_errors %}
      <div>{{ error }}</div>
      {% endfor %}
    </div>
    {% endif %}

    <input type="text" name="username" placeholder="Phone number or email" required />
    <input type="password" name="password" placeholder="Password" required />
    <button type="submit" name="login_submit">Login</button>
  </form>
</div>
{% endblock content %}
_______________________________________________________________________________________________
videochat_app/chat/templates/registration/signup.html

{% extends "base_auth.html" %} {% load static %} {% block title %}Sign Up{% endblock title %} {% block content %}
<h2>Sign Up</h2>
<div class="form-wrapper">
  <form method="post">
    {% csrf_token %} {% if form.errors %}
    <div class="error-box">
      {% for field in form %} {% for error in field.errors %}
      <div>{{ error }}</div>
      {% endfor %} {% endfor %} {% for error in form.non_field_errors %}
      <div>{{ error }}</div>
      {% endfor %}
    </div>
    {% endif %}

    <input type="text" name="username" placeholder="Username" required />
    <input type="email" name="email" placeholder="Email" />
    <input type="password" name="password1" placeholder="Password" required />
    <input type="password" name="password2" placeholder="Confirm Password" required />
    <button type="submit">Sign Up</button>
  </form>
</div>
{% endblock content %}
_______________________________________________________________________________________________
videochat_app/chat/templates/base_auth.html

{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block title %}Auth{% endblock %}</title>
    <link rel="stylesheet" href="{% static 'css/base_auth.css' %}" />
  </head>

  <body>
    <div class="auth-container">
      <div class="auth-header">
        <button
          id="login-tab"
          class="{% if request.resolver_match.url_name == 'login' %}active{% endif %}"
          onclick="location.href='{% url 'login' %}'"
        >
          Login
        </button>
        <button
          id="signup-tab"
          class="{% if request.resolver_match.url_name == 'signup' %}active{% endif %}"
          onclick="location.href='{% url 'signup' %}'"
        >
          Sign Up
        </button>
      </div>
      <div class="auth-content">{% block content %}{% endblock %}</div>
    </div>
  </body>
</html>
_______________________________________________________________________________________________
videochat_app/chat/consumers.py

import json
from datetime import datetime

from asgiref.sync import sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async

from .mongo import get_db

# Global set to keep track of online users (for InMemoryChannelLayer)
# In a production environment with multiple Daphne instances, this would need to be
# replaced with a shared state mechanism like Redis.
online_users = set()

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_name = self.scope["url_route"]["kwargs"]["room_name"]
        self.room_group_name = f"chat_{self.room_name}"

        user = self.scope.get("user")
        self.username = (
            str(user.username) if getattr(user, "is_authenticated", False) else "Anonymous"
        )

        # Add user to a specific group for direct messaging (if needed, otherwise room_group_name is enough)
        self.user_channel_name = f"user_{self.username}"
        await self.channel_layer.group_add(self.user_channel_name, self.channel_name)

        await self.channel_layer.group_add(self.room_group_name, self.channel_name)
        await self.channel_layer.group_add("global_presence", self.channel_name) # Add to global presence group
        await self.accept()

        # Add user to online users set and broadcast status
        if self.username != "Anonymous":
            online_users.add(self.username)
            await self.broadcast_user_status(self.username, True)

            # Send the current list of online users to the newly connected user
            online_users_list = await self.get_online_users()
            await self.send(text_data=json.dumps({
                "type": "online_users_list",
                "users": online_users_list,
            }))

        try:
            join_msg = {
                "type": "join",
                "from": self.username,
                "event_type": "join",
                "sender": self.username,
            }
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "room_event", "message": join_msg},
            )
        except Exception:
            pass

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.room_group_name, self.channel_name)
        await self.channel_layer.group_discard(self.user_channel_name, self.channel_name)
        await self.channel_layer.group_discard("global_presence", self.channel_name) # Discard from global presence group

        # Remove user from online users set and broadcast status
        if self.username != "Anonymous":
            online_users.discard(self.username)
            await self.broadcast_user_status(self.username, False)

        try:
            leave_msg = {
                "type": "leave",
                "from": self.username,
                "event_type": "leave",
                "sender": self.username,
            }
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "room_event", "message": leave_msg},
            )
        except Exception:
            pass

    async def broadcast_user_status(self, username, is_online):
        """Broadcasts a user's online/offline status to all relevant groups."""
        status_message = {
            "type": "user_status",
            "username": username,
            "is_online": is_online,
        }
        # Broadcast to a global presence group (if one existed) or to all rooms
        # For simplicity, broadcasting to all rooms for now.
        # In a larger app, a dedicated 'presence' group would be better.
        await self.channel_layer.group_send(
            "global_presence",
            {"type": "send_user_status", "message": status_message},
        )

    async def send_user_status(self, event):
        """Handles the 'send_user_status' event to send status updates to the websocket."""
        message = event["message"]
        await self.send(text_data=json.dumps(message))

    async def get_online_users(self):
        """Returns the list of currently online users."""
        return list(online_users)

    async def receive(self, text_data=None, bytes_data=None):
        if not text_data:
            return

        try:
            data = json.loads(text_data)
        except Exception:
            return

        msg_type = data.get("type")
        payload = {k: v for k, v in data.items() if k != "type"}
        sender = self.username

        out = {
            "type": msg_type,
            "from": sender,
            "event_type": msg_type,
            "sender": sender,
            **payload,
        }

        db = get_db()
        if db:
            try:
                if msg_type == "chat":
                    doc = {
                        "room": self.room_name,
                        "sender": sender,
                        "message": payload.get("message", ""),
                        "timestamp": datetime.utcnow(),
                    }
                    await sync_to_async(db.chats.insert_one)(doc)

                elif msg_type in (
                    "offer", "answer", "ice",
                    "call", "missed_call",
                    "end_call", "reject"
                ):
                    doc = {
                        "room": self.room_name,
                        "sender": sender,
                        "type": msg_type,
                        "payload": payload,
                        "timestamp": datetime.utcnow(),
                    }
                    await sync_to_async(db.notifications.insert_one)(doc)

            except Exception as e:
                print(f"[MongoDB] save failed: {e}")

        # Determine if the message should be sent to a specific user or broadcast
        to_user = data.get("to")
        if msg_type == "get_online_users":
            online_users_list = await self.get_online_users()
            await self.send(text_data=json.dumps({
                "type": "online_users_list",
                "users": online_users_list,
            }))
        elif to_user:
            # Send directly to the target user's channel
            await self.channel_layer.group_send(
                f"user_{to_user}", # Send to user-specific channel
                {"type": "room_event", "message": out},
            )
        else:
            # Broadcast to the entire room group
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "room_event", "message": out},
            )

    async def room_event(self, event):
        message = event.get("message", {})
        try:
            await self.send(text_data=json.dumps(message))
        except Exception:
            pass
_______________________________________________________________________________________________
videochat_app/chat/mongo.py

import os
from pymongo import MongoClient
from django.conf import settings

_client = None
_db = None

def _init():
    global _client, _db
    uri = getattr(settings, "MONGO_URI", "") or os.getenv("MONGO_URI", "")
    dbname = getattr(settings, "MONGO_DB_NAME", "") or os.getenv("MONGO_DB_NAME", "")
    if uri and dbname:
        try:
            _client = MongoClient(uri, serverSelectionTimeoutMS=3000)
            _client.server_info()
            _db = _client[dbname]
        except Exception as e:
            print(f"[MongoDB] connection failed: {e}")
            _client = None
            _db = None

def get_db():
    global _db
    if _db is None:
        _init()
    return _db
_______________________________________________________________________________________________
videochat_app/chat/routing.py

from django.urls import re_path
from .consumers import ChatConsumer

websocket_urlpatterns = [
    re_path(r"^ws/chat/(?P<room_name>[^/]+)/$", ChatConsumer.as_asgi()),
]
_______________________________________________________________________________________________
videochat_app/chat/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('notifications/', views.notifications, name='notifications'),
    path('room/<str:username>/', views.room_with_user, name='room_with_user'),
    path('call/<str:username>/', views.room_with_user, name='call_user'),  # legacy alias
]
_______________________________________________________________________________________________
videochat_app/chat/views.py

from django.contrib.auth.decorators import login_required
from django.contrib.auth import get_user_model
from django.shortcuts import render, get_object_or_404
from django.http import Http404
from django.conf import settings # Import settings
from chat.mongo import get_db  # you already use this elsewhere

User = get_user_model()

def _pair_room_name(a, b):
    a, b = sorted([a, b])
    return f"{a}_{b}"

@login_required
def home(request):
    users = User.objects.exclude(id=request.user.id).order_by("username")
    return render(request, "chat/home.html", {"users": users})

@login_required
def room_with_user(request, username):
    peer = get_object_or_404(User, username=username)
    if peer.id == request.user.id:
        raise Http404("Cannot call yourself.")

    room_name = _pair_room_name(request.user.username, peer.username)

    # preload last 50 chat messages from Mongo (if available)
    history = []
    db = get_db()
    if db:
        try:
            cur = db.chats.find({"room": room_name}).sort("timestamp", -1).limit(50)
            history = list(reversed(list(cur)))
        except Exception as e:
            print(f"[MongoDB] fetch history failed: {e}")

    users = User.objects.exclude(id=request.user.id).order_by("username")
    return render(
        request,
        "chat/room.html",
        {
            "peer": peer,
            "room_name": room_name,
            "history": history,
            "users": users,
            "webrtc_ice_servers": settings.WEBRTC_ICE_SERVERS, # Pass ICE servers to template
        },
    )

@login_required
def notifications(request):
    logs = []
    db = get_db()
    if db:
        try:
            cursor = db.notifications.find().sort("timestamp", -1).limit(50)
            logs = list(cursor)
        except Exception as e:
            print(f"[MongoDB] fetch notifications failed: {e}")
    return render(request, "chat/notifications.html", {"logs": logs})
_______________________________________________________________________________________________
static/css/app.css

/* WhatsApp-like Theme */

/* Variables */
:root {
    --whatsapp-green: #075e54;
    --whatsapp-light-green: #128c7e;
    --whatsapp-bg-dark: #0b141a;
    --whatsapp-bg-light: #111b21;
    --whatsapp-text-primary: #e9edef;
    --whatsapp-text-secondary: #8696a0;
    --whatsapp-border: #222e35;
    --whatsapp-bubble-me: #005c4b;
    --whatsapp-bubble-peer: #202c33;
    --whatsapp-icon: #aebac1;
}

/* Reset-ish */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    background: var(--whatsapp-bg-dark);
    color: var(--whatsapp-text-primary);
}

/* Buttons */
.btn {
    border: 0;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s ease;
}

.btn-ghost {
    background: transparent;
    color: var(--whatsapp-icon);
}

.btn-ghost:hover {
    background: rgba(255, 255, 255, 0.1);
}

.btn-primary {
    background: var(--whatsapp-light-green);
    color: #fff;
}

.btn-primary:hover {
    filter: brightness(1.1);
}

.btn-danger {
    background: #e63d3d;
    color: #fff;
}

/* Topbar */
.topbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px;
    background: var(--whatsapp-green);
    border-bottom: 1px solid var(--whatsapp-green);
    color: #fff;
}

.brand {
    color: #fff;
    text-decoration: none;
    font-weight: 700;
    font-size: 18px;
}

.topbar__right {
    display: flex;
    gap: 15px;
    align-items: center;
}

.topbar__right span {
    color: rgba(255, 255, 255, 0.8);
}

.topbar__right .btn-ghost {
    color: #fff;
}

.whoami {
    opacity: .9;
}

.logout-form {
    display: inline;
}

/* Workspace (below topbar) */
.workspace {
    display: grid;
    grid-template-columns: 360px 1fr;
    height: calc(100vh - 52px);
    margin-top: 52px;
}

/* Left pane */
.pane--left {
    background: var(--whatsapp-bg-light);
    border-right: 1px solid var(--whatsapp-border);
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.sidebar {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.sidebar__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: var(--whatsapp-bubble-peer);
    border-bottom: 1px solid var(--whatsapp-border);
}

.sidebar__header .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #aebac1;
    display: grid;
    place-items: center;
    font-weight: 700;
    color: var(--whatsapp-bg-light);
}

.sidebar__header .actions {
    display: flex;
    gap: 15px;
}

.sidebar__header .actions .btn-ghost {
    font-size: 20px;
    padding: 5px;
    border-radius: 50%;
}

.sidebar__search {
    padding: 8px 10px;
    border-bottom: 1px solid var(--whatsapp-border);
    background: var(--whatsapp-bg-light);
}

.sidebar__search input {
    width: 100%;
    padding: 8px 12px;
    border-radius: 20px;
    border: none;
    background: var(--whatsapp-bubble-peer);
    color: var(--whatsapp-text-primary);
    outline: none;
    font-size: 14px;
}

.sidebar__search input::placeholder {
    color: var(--whatsapp-text-secondary);
}

.chat-list {
    list-style: none;
    margin: 0;
    padding: 0;
    overflow-y: auto;
    flex: 1;
}

.chat-item {
    border-bottom: 1px solid var(--whatsapp-border);
}

.chat-item--empty {
    padding: 16px;
    color: var(--whatsapp-text-secondary);
    text-align: center;
}

.chat-item__link {
    display: grid;
    grid-template-columns: 50px 1fr auto;
    gap: 10px;
    padding: 12px 16px;
    text-decoration: none;
    color: inherit;
    align-items: center;
}

.chat-item.is-active,
.chat-item__link:hover {
    background: var(--whatsapp-bubble-peer);
}

.chat-item__avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #aebac1;
    color: var(--whatsapp-bg-light);
    display: grid;
    place-items: center;
    font-weight: 700;
    font-size: 16px;
}

.chat-item__meta {
    overflow: hidden;
}

.chat-item__top {
    display: flex;
    justify-content: space-between;
    font-size: 15px;
    margin-bottom: 2px;
}

.chat-item__name {
    font-weight: 600;
    color: var(--whatsapp-text-primary);
}

.chat-item__time {
    color: var(--whatsapp-text-secondary);
    font-size: 12px;
}

.chat-item__last {
    color: var(--whatsapp-text-secondary);
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.chat-item__badge {
    align-self: center;
    background: var(--whatsapp-light-green);
    color: #fff;
    font-weight: 600;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 12px;
}

/* Right pane / Chat window */
.pane--right {
    background: var(--whatsapp-bg-dark);
    display: flex;
    flex-direction: column;
}

.chat {
    flex: 1;
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    /* Ensure chat container takes full height */
}

.chat__header {
    height: 60px;
    flex: 0 0 60px;
    padding: 10px 16px;
    border-bottom: 1px solid var(--whatsapp-border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--whatsapp-bubble-peer);
}

.peer {
    display: flex;
    gap: 10px;
    align-items: center;
}

.peer__avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #aebac1;
    color: var(--whatsapp-bg-light);
    display: grid;
    place-items: center;
    font-weight: 700;
    font-size: 16px;
}

.peer__name {
    font-weight: 600;
    color: var(--whatsapp-text-primary);
}

.peer__status {
    font-size: 12px;
    color: var(--whatsapp-text-secondary);
}

.chat__header .actions {
    display: flex;
    gap: 15px;
}

.chat__header .actions .btn-ghost {
    font-size: 20px;
    padding: 5px;
    border-radius: 50%;
}

.chat__messages {
    flex-grow: 1;
    /* Allow messages to grow and take available space */
    overflow-y: auto;
    /* background-image: url('/static/img/whatsapp-bg.png'); */
    /* Placeholder for chat background */
    background-size: cover;
    background-position: center;
    padding: 16px 24px;
    display: flex;
    flex-direction: column;
    /* Ensure messages push to the top, leaving space for composer */
    justify-content: flex-end;
}

.msg {
    display: flex;
    margin: 8px 0;
}

.msg--me {
    justify-content: flex-end;
}

.msg__bubble {
    max-width: 70%;
    padding: 10px 12px;
    border-radius: 10px;
    background: var(--whatsapp-bubble-peer);
    color: var(--whatsapp-text-primary);
    position: relative;
}

.msg--me .msg__bubble {
    background: var(--whatsapp-bubble-me);
}

.msg__text {
    white-space: pre-wrap;
    word-wrap: break-word;
}

.msg__time {
    text-align: right;
    font-size: 11px;
    color: rgba(255, 255, 255, 0.6);
    margin-top: 4px;
}

.chat__empty {
    color: var(--whatsapp-text-secondary);
    text-align: center;
    margin-top: 40px;
}

.composer {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 8px;
    padding: 8px 16px;
    background: var(--whatsapp-bubble-peer);
    align-items: center;
    flex-shrink: 0;
    /* Prevent composer from shrinking */
}

.composer__btn {
    background: transparent;
    border: none;
    color: var(--whatsapp-icon);
    font-size: 24px;
    padding: 0;
    width: 40px;
    height: 40px;
    display: grid;
    place-items: center;
    border-radius: 50%;
}

.composer__btn:hover {
    background: rgba(255, 255, 255, 0.1);
}

.composer__input {
    border: none;
    background: var(--whatsapp-bg-light);
    color: var(--whatsapp-text-primary);
    padding: 10px 12px;
    border-radius: 20px;
    outline: none;
    font-size: 15px;
}

.composer__input::placeholder {
    color: var(--whatsapp-text-secondary);
}

/* Popups (WhatsApp style) */
.popup {
    position: fixed;
    right: 20px;
    background: var(--whatsapp-bubble-peer);
    border: 1px solid var(--whatsapp-border);
    border-radius: 8px;
    padding: 14px;
    box-shadow: 0 8px 22px rgba(0, 0, 0, .4);
    min-width: 280px;
    display: none;
    z-index: 2000;
    color: var(--whatsapp-text-primary);
}

#popup-message {
    bottom: 20px;
}

#popup-call {
    bottom: 120px;
}

.popup h4 {
    margin: 0 0 6px 0;
    font-size: 16px;
    color: var(--whatsapp-light-green);
}

.popup p {
    color: var(--whatsapp-text-secondary);
    margin: 0;
}

.popup .actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

/* Generic empty state */
.empty-state {
    place-self: center;
    text-align: center;
    color: var(--whatsapp-text-secondary);
    background: var(--whatsapp-bubble-peer);
    border: 1px solid var(--whatsapp-border);
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
}

/* Floating Call Window */
.call-window {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--whatsapp-bg-dark);
    border-radius: 12px;
    box-shadow: 0 8px 22px rgba(0, 0, 0, 0.4);
    overflow: hidden;
    z-index: 3000;
    display: none;
    min-width: 200px;
    min-height: 150px;
    max-width: 90vw;
    max-height: 90vh;
    transition: all 0.3s ease-in-out;
    border: 1px solid var(--whatsapp-border);
}

.call-window.minimized {
    width: 300px;
    height: 200px;
}

.call-window.maximized {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    border-radius: 0;
}

.call-header {
    background: var(--whatsapp-bubble-peer);
    color: var(--whatsapp-text-primary);
    padding: 8px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab;
    border-bottom: 1px solid var(--whatsapp-border);
}

.call-header-actions {
    display: flex;
    gap: 8px;
}

.call-header .btn {
    font-size: 14px;
    width: 28px;
    height: 28px;
    background: var(--whatsapp-bg-light);
    color: var(--whatsapp-icon);
    border-radius: 50%;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.call-header .btn:hover {
    background: var(--whatsapp-border);
}

.call-body {
    position: relative;
    width: 100%;
    height: calc(100% - 44px);
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.call-window.minimized .call-body {
    height: calc(100% - 44px);
}

.call-window.maximized .call-body {
    height: calc(100% - 44px);
}

#remoteVideo {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #000;
}

#localVideo {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 120px;
    height: 90px;
    border-radius: 8px;
    object-fit: cover;
    border: 2px solid var(--whatsapp-light-green);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    background: #000;
    transition: all 0.3s ease-in-out;
}

.call-window.maximized #localVideo {
    width: 180px;
    height: 135px;
}

.call-window.maximized #localVideo.hidden {
    display: none;
}

.call-controls {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    background: rgba(0, 0, 0, 0.6);
    padding: 8px 15px;
    border-radius: 25px;
    backdrop-filter: blur(5px);
}

.call-controls .btn {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
    font-size: 20px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s ease;
    padding: 0;
}

.call-controls .btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.call-controls .btn.active {
    background: var(--whatsapp-light-green);
}

.call-controls .btn.active:hover {
    background: #00c29e;
}

.call-controls .btn-danger {
    background: #e63d3d;
}

.call-controls .btn-danger:hover {
    background: #ff5c5c;
}
_______________________________________________________________________________________________
static/css/base_auth.css

body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: #f0f2f5;
    /* Light grey background */
    margin: 0;
    padding: 20px;
    /* Add some padding for mobile view */
    box-sizing: border-box;
}

.auth-container {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.1);
    width: 100%;
    max-width: 400px;
    /* Max width for desktop */
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.auth-header {
    display: flex;
    justify-content: space-around;
    background-color: #075e54;
    /* WhatsApp dark green */
    padding: 15px 0;
    border-bottom: 1px solid #ece5dd;
}

.auth-header button {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 18px;
    font-weight: 500;
    cursor: pointer;
    padding: 5px 10px;
    transition: color 0.3s ease;
}

.auth-header button.active {
    color: white;
    border-bottom: 2px solid white;
}

.auth-header button:hover:not(.active) {
    color: rgba(255, 255, 255, 0.9);
}

.auth-content {
    padding: 25px;
    background-color: #ece5dd;
    /* WhatsApp light background */
    flex-grow: 1;
}

h2 {
    text-align: center;
    color: #1f2d3d;
    /* Darker text for headings */
    margin-bottom: 25px;
    font-size: 24px;
}

.form-wrapper {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

input[type="text"],
input[type="email"],
input[type="password"] {
    width: 100%;
    padding: 12px 15px;
    border: 1px solid #ccc;
    border-radius: 20px;
    /* Rounded input fields */
    font-size: 16px;
    box-sizing: border-box;
    background-color: #fdfdfd;
    transition: border-color 0.2s ease;
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="password"]:focus {
    border-color: #25d366;
    /* WhatsApp green on focus */
    outline: none;
}

button[type="submit"] {
    width: 100%;
    padding: 12px 15px;
    background: #25d366;
    /* WhatsApp green button */
    color: white;
    border: none;
    border-radius: 20px;
    /* Rounded buttons */
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background-color 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

button[type="submit"]:hover {
    background: #1da851;
    /* Darker green on hover */
}

.error-box {
    background: #ffebee;
    /* Light red for errors */
    color: #d32f2f;
    /* Dark red text */
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 14px;
    margin-bottom: 15px;
    border: 1px solid #ef9a9a;
}

.error-box div {
    margin-bottom: 5px;
}

.error-box div:last-child {
    margin-bottom: 0;
}

.link-text {
    text-align: center;
    margin-top: 20px;
    font-size: 15px;
    color: #555;
}

.link-text a {
    color: #075e54;
    /* WhatsApp dark green for links */
    text-decoration: none;
    font-weight: 500;
}

.link-text a:hover {
    text-decoration: underline;
}

/* Mobile-first adjustments */
@media (max-width: 600px) {
    body {
        padding: 0;
        background: #075e54;
        /* Dark green background for full mobile screen */
    }

    .auth-container {
        border-radius: 0;
        box-shadow: none;
        height: 100vh;
        max-width: none;
    }

    .auth-content {
        padding: 20px;
    }

    h2 {
        font-size: 22px;
        margin-bottom: 20px;
    }

    input[type="text"],
    input[type="email"],
    input[type="password"],
    button[type="submit"] {
        padding: 15px;
        font-size: 17px;
    }
}
_______________________________________________________________________________________________
static/js/chat.js

(() => {
  const { me, roomName } = window.APP_CONTEXT;
  const showPopup = window.showPopup || ((id, text) => {});
  const hidePopup = window.hidePopup || ((id) => {});

  const chatBox = document.getElementById("chatBox");
  const messageInput = document.getElementById("messageInput");
  const messageForm = document.getElementById("messageForm");
  const sidebarUsers = document.getElementById("sidebarUsers"); // Assuming an element with this ID for the user list
  const chatHeaderStatus = document.getElementById("chatHeaderStatus"); // Assuming an element for chat header status

  let ws;
  const onlineUsers = new Set(); // Client-side tracking of online users

  function sendWS(payload) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(payload));
    }
  }

  function appendMessage(sender, message, timestamp) {
    const msgDiv = document.createElement("div");
    msgDiv.classList.add("msg");
    msgDiv.classList.add(sender === me ? "msg--me" : "msg--peer");

    const msgBubble = document.createElement("div");
    msgBubble.classList.add("msg__bubble");

    const msgText = document.createElement("div");
    msgText.classList.add("msg__text");
    msgText.innerText = message;

    const msgTime = document.createElement("div");
    msgTime.classList.add("msg__time");
    msgTime.innerText = timestamp; // Format as needed, e.g., new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })

    msgBubble.appendChild(msgText);
    msgBubble.appendChild(msgTime);
    msgDiv.appendChild(msgBubble);
    chatBox.appendChild(msgDiv);

    // Scroll to the bottom of the chat box
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  function connectWS() {
    ws = new WebSocket(window.APP_CONTEXT.wsUrl);

    ws.onmessage = (evt) => {
      const data = JSON.parse(evt.data);
      const t = data.type;
      const from = data.from;
      const to = data.to;

      if (to && to !== me) return;

      switch (t) {
        case "chat":
          console.log("Chat:", from, data.message);
          // Append new chat message to the chat box
          const timestamp = new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }); // Or use data.timestamp if available and formatted
          appendMessage(from, data.message, timestamp);
          break;

        case "user_status":
          handleUserStatus(data.username, data.is_online);
          break;

        case "online_users_list":
          updateOnlineUsersList(data.users);
          break;

        case "missed_call":
          showPopup("popup-message", "Missed call from " + from);
          setTimeout(() => hidePopup("popup-message"), 4000);
          break;

        case "end_call":
          // Handle graceful call ending if peer goes inactive during a call
          // This assumes `webrtc.js` has a function to end the call
          if (window.webrtc && window.webrtc.endCall) {
            window.webrtc.endCall();
            showPopup("popup-message", `${from} has ended the call.`);
            setTimeout(() => hidePopup("popup-message"), 4000);
          }
          break;

        default:
          // ignore all other events
          break;
      }
    };

    ws.onopen = () => {
      console.log("WebSocket connected.");
    };

    ws.onclose = () => {
      console.log("WebSocket disconnected. Reconnecting in 3 seconds...");
      setTimeout(connectWS, 3000);
    };

    ws.onerror = (err) => {
      console.error("WebSocket error:", err);
      ws.close();
    };
  }

  // Handle message form submission
  if (messageForm) {
    messageForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const message = messageInput.value.trim();
      if (message) {
        sendWS({
          type: "chat",
          message: message,
          room: roomName,
        });
        messageInput.value = ""; // Clear input field
      }
    });
  }

  function handleUserStatus(username, isOnline) {
    if (isOnline) {
      onlineUsers.add(username);
    } else {
      onlineUsers.delete(username);
    }
    updateSidebarUserStatus(username, isOnline);
    updateChatHeaderStatus();
  }

  function updateOnlineUsersList(users) {
    onlineUsers.clear();
    users.forEach((user) => onlineUsers.add(user));
    // Re-render sidebar users to reflect initial online status
    if (sidebarUsers) {
      Array.from(sidebarUsers.children).forEach((userDiv) => {
        const username = userDiv.dataset.username;
        if (username) {
          updateSidebarUserStatus(username, onlineUsers.has(username));
        }
      });
    }
    updateChatHeaderStatus();
  }

  function updateSidebarUserStatus(username, isOnline) {
    if (sidebarUsers) {
      const userDiv = sidebarUsers.querySelector(
        `[data-username="${username}"]`
      );
      if (userDiv) {
        let statusSpan = userDiv.querySelector(".user-status");
        if (!statusSpan) {
          statusSpan = document.createElement("span");
          statusSpan.classList.add("user-status");
          userDiv.appendChild(statusSpan);
        }
        statusSpan.textContent = isOnline ? " (Online)" : " (Offline)";
        statusSpan.style.color = isOnline ? "green" : "red";
      }
    }
  }

  function updateChatHeaderStatus() {
    if (chatHeaderStatus) {
      const peerUsername = chatHeaderStatus.dataset.peerUsername; // Assuming data-peer-username attribute
      if (peerUsername) {
        const isOnline = onlineUsers.has(peerUsername);
        chatHeaderStatus.textContent = isOnline ? "Online" : "Offline";
        chatHeaderStatus.style.color = isOnline ? "green" : "red";
      }
    }
  }

  // Expose onlineUsers for webrtc.js to check peer status before calling
  window.getOnlineUsers = () => onlineUsers;

  connectWS();
})();
_______________________________________________________________________________________________
static/js/global-call-manager.js

// Global Call Manager - Handles video calls across chat switches
(() => {
  "use strict";

  // Global call state
  window.GlobalCallManager = {
    currentCall: null,
    incomingCall: null,
    localStream: null,
    remoteStream: null,
    isInitialized: false,
    currentPeerConnection: null,
    currentWebSocket: null,
    isMinimized: true,
    isMicOn: true,
    isCamOn: true,

    // UI elements
    callWindow: null,
    localVideo: null,
    remoteVideo: null,
    btnMinimizeMaximize: null,
    btnEndCall: null,
    btnToggleMic: null,
    btnToggleCamera: null,
    btnHangUp: null, // New hang up button
    callTitle: null,

    // Initialize the global call manager
    init() {
      if (this.isInitialized) return;
      this.isInitialized = true;

      // Get UI references
      this.callWindow = document.getElementById("callWindow");
      this.localVideo = document.getElementById("localVideo");
      this.remoteVideo = document.getElementById("remoteVideo");
      this.btnMinimizeMaximize = document.getElementById("btnMinimizeMaximize");
      this.btnEndCall = document.getElementById("btnEndCall"); // This is the 'X' button
      this.btnToggleMic = document.getElementById("btnToggleMic");
      this.btnToggleCamera = document.getElementById("btnToggleCamera");
      this.btnHangUp = document.getElementById("btnHangUp"); // Reference the new hang up button
      this.callTitle = document.getElementById("callTitle");

      // Add event listeners
      if (this.btnMinimizeMaximize) {
        this.btnMinimizeMaximize.addEventListener("click", () =>
          this.toggleMinimizeMaximize()
        );
      }
      if (this.btnEndCall) {
        this.btnEndCall.addEventListener("click", () => this.endCall());
      }
      if (this.btnToggleMic) {
        this.btnToggleMic.addEventListener("click", () => this.toggleMic());
      }
      if (this.btnToggleCamera) {
        this.btnToggleCamera.addEventListener("click", () =>
          this.toggleCamera()
        );
      }
      if (this.btnHangUp) {
        this.btnHangUp.addEventListener("click", () => this.endCall());
      }

      // Make call window draggable
      this.makeDraggable(
        this.callWindow,
        this.callWindow.querySelector(".call-header")
      );

      // Listen for storage changes to sync across tabs/pages
      window.addEventListener("storage", (e) => {
        if (e.key === "activeCall") {
          this.handleCallStateChange(e.newValue);
        }
      });

      // Check for existing call state on page load
      this.restoreCallState();

      // Set up periodic cleanup of expired calls
      setInterval(() => this.cleanupExpiredCalls(), 5000);
    },

    // Set local video stream
    setLocalStream(stream) {
      this.localStream = stream;
      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }
      this.updateControlButtons();
    },

    // Set remote video stream
    setRemoteStream(stream) {
      this.remoteStream = stream;
      if (this.remoteVideo) {
        this.remoteVideo.srcObject = stream;
      }
    },

    // Show the call window
    showCallWindow() {
      if (this.callWindow) {
        this.callWindow.style.display = "block";
        // When showing, default to maximized for better initial experience
        this.callWindow.classList.remove("minimized");
        this.callWindow.classList.add("maximized");
        this.isMinimized = false; // Set to false as it's maximized
        this.updateMinimizeMaximizeIcon();
        this.updateControlButtons();
        this.updateLocalVideoVisibility(); // Ensure local video visibility is correct
      }
    },

    // Hide the call window
    hideCallWindow() {
      if (this.callWindow) {
        this.callWindow.style.display = "none";
        this.callWindow.classList.remove("minimized", "maximized");
      }
    },

    // Toggle minimize/maximize
    toggleMinimizeMaximize() {
      if (this.callWindow) {
        this.isMinimized = !this.isMinimized;
        this.callWindow.classList.toggle("minimized", this.isMinimized);
        this.callWindow.classList.toggle("maximized", !this.isMinimized);
        this.updateMinimizeMaximizeIcon();
        this.updateLocalVideoVisibility();
      }
    },

    // Update minimize/maximize icon
    updateMinimizeMaximizeIcon() {
      if (this.btnMinimizeMaximize) {
        const icon = this.btnMinimizeMaximize.querySelector("i");
        if (icon) {
          icon.classList.toggle("fa-expand-alt", this.isMinimized);
          icon.classList.toggle("fa-compress-alt", !this.isMinimized);
        }
      }
    },

    // Toggle microphone
    toggleMic() {
      if (this.localStream) {
        this.isMicOn = !this.isMicOn;
        this.localStream.getAudioTracks().forEach((track) => {
          track.enabled = this.isMicOn;
        });
        this.updateControlButtons();
      }
    },

    // Toggle camera
    toggleCamera() {
      if (this.localStream) {
        this.isCamOn = !this.isCamOn;
        this.localStream.getVideoTracks().forEach((track) => {
          track.enabled = this.isCamOn;
        });
        this.updateControlButtons();
        this.updateLocalVideoVisibility();
      }
    },

    // Update control button states
    updateControlButtons() {
      if (this.btnToggleMic) {
        this.btnToggleMic.classList.toggle("active", this.isMicOn);
        this.btnToggleMic.querySelector("i").className = this.isMicOn
          ? "fas fa-microphone"
          : "fas fa-microphone-slash";
      }
      if (this.btnToggleCamera) {
        this.btnToggleCamera.classList.toggle("active", this.isCamOn);
        this.btnToggleCamera.querySelector("i").className = this.isCamOn
          ? "fas fa-video"
          : "fas fa-video-slash";
      }
    },

    // Update local video visibility based on camera state and maximized mode
    updateLocalVideoVisibility() {
      if (this.localVideo) {
        const isMaximized = this.callWindow.classList.contains("maximized");
        if (isMaximized && !this.isCamOn) {
          this.localVideo.classList.add("hidden");
        } else {
          this.localVideo.classList.remove("hidden");
        }
      }
    },

    // Make an element draggable
    makeDraggable(element, handle) {
      let pos1 = 0,
        pos2 = 0,
        pos3 = 0,
        pos4 = 0;
      if (handle) {
        handle.onmousedown = dragMouseDown;
      } else {
        element.onmousedown = dragMouseDown;
      }

      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // get the mouse cursor position at startup:
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        // call a function whenever the cursor moves:
        document.onmousemove = elementDrag;
      }

      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // calculate the new cursor position:
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        // set the element's new position:
        element.style.top = element.offsetTop - pos2 + "px";
        element.style.left = element.offsetLeft - pos1 + "px";
      }

      function closeDragElement() {
        // stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
      }
    },

    // Save call state to localStorage
    saveCallState(callData) {
      const state = {
        ...callData,
        timestamp: Date.now(),
        currentPage: window.location.pathname,
      };
      localStorage.setItem("activeCall", JSON.stringify(state));
    },

    // Get call state from localStorage
    getCallState() {
      const stored = localStorage.getItem("activeCall");
      if (!stored) return null;

      try {
        const state = JSON.parse(stored);
        // Expire calls older than 2 minutes
        if (Date.now() - state.timestamp > 120000) {
          this.clearCallState();
          return null;
        }
        return state;
      } catch (e) {
        this.clearCallState();
        return null;
      }
    },

    // Clear call state
    clearCallState() {
      localStorage.removeItem("activeCall");
      this.currentCall = null;
      this.incomingCall = null;
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }
      this.remoteStream = null;
      if (this.localVideo) this.localVideo.srcObject = null;
      if (this.remoteVideo) this.remoteVideo.srcObject = null;
      this.hideCallWindow();
    },

    // Handle incoming call
    handleIncomingCall(callData) {
      this.incomingCall = callData;
      this.saveCallState({
        type: "incoming",
        from: callData.from,
        offer: callData.offer,
        room: callData.room || this.getCurrentRoom(),
      });

      // Show global call popup
      this.showGlobalCallPopup(callData.from);
    },

    // Handle call acceptance
    async acceptCall() {
      if (!this.incomingCall) return;

      try {
        // Get user media
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true,
        });
        this.setLocalStream(stream);

        // Update call state
        this.currentCall = {
          type: "active",
          peer: this.incomingCall.from,
          room: this.incomingCall.room,
        };

        this.saveCallState(this.currentCall);
        this.hideGlobalCallPopup();
        this.showCallWindow(); // Show the floating window

        // Navigate to the correct room if not already there
        const expectedRoom = this.incomingCall.room;
        if (this.getCurrentRoom() !== expectedRoom) {
          const peerUsername = this.incomingCall.from;
          window.location.href = `/chat/${peerUsername}/`;
          return;
        }

        // Trigger acceptance in the current room
        this.triggerRoomCallAcceptance();
      } catch (error) {
        console.error("Error accepting call:", error);
        this.rejectCall();
      }
    },

    // Handle call rejection
    rejectCall() {
      if (this.incomingCall) {
        // Send rejection through current WebSocket if available
        if (this.currentWebSocket) {
          this.currentWebSocket.send(
            JSON.stringify({
              type: "reject",
              to: this.incomingCall.from,
            })
          );
        }
      }

      this.clearCallState();
      this.hideGlobalCallPopup();
    },

    // Handle call end
    endCall() {
      if (this.currentCall) {
        // Send end call through current WebSocket if available
        if (this.currentWebSocket) {
          this.currentWebSocket.send(
            JSON.stringify({
              type: "end_call",
              to: this.currentCall.peer,
            })
          );
        }
      }

      // Stop local stream
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      // Close peer connection
      if (this.currentPeerConnection) {
        this.currentPeerConnection.close();
        this.currentPeerConnection = null;
      }

      this.clearCallState();
      this.hideCallWindow();
    },

    // Show global call popup (for incoming calls)
    showGlobalCallPopup(callerName) {
      const popup = document.getElementById("popup-call");
      const popupText = document.getElementById("popup-call-text");
      if (popup && popupText) {
        popupText.innerText = `${callerName} is calling you...`;
        popup.style.display = "block";
      }
    },

    // Hide global call popup
    hideGlobalCallPopup() {
      const popup = document.getElementById("popup-call");
      if (popup) {
        popup.style.display = "none";
      }
    },

    // Restore call state on page load
    restoreCallState() {
      const state = this.getCallState();
      if (!state) return;

      if (state.type === "incoming") {
        this.incomingCall = state;
        this.showGlobalCallPopup(state.from);
      } else if (state.type === "active") {
        this.currentCall = state;
        this.showCallWindow(); // Show the floating window and maximize it
        // The room-specific code will handle active call restoration of streams
      }
    },

    // Handle call state changes from other tabs/pages
    handleCallStateChange(newStateJson) {
      if (!newStateJson) {
        this.hideGlobalCallPopup();
        this.clearCallState(); // Clear all state if no active call
        return;
      }

      try {
        const newState = JSON.parse(newStateJson);
        if (newState.type === "incoming") {
          this.incomingCall = newState;
          this.showGlobalCallPopup(newState.from);
        } else if (newState.type === "active") {
          this.currentCall = newState;
          this.hideGlobalCallPopup();
          this.showCallWindow();
        } else {
          this.hideGlobalCallPopup();
          this.clearCallState();
        }
      } catch (e) {
        console.error("Error parsing call state:", e);
        this.clearCallState();
      }
    },

    // Get current room name from URL
    getCurrentRoom() {
      const path = window.location.pathname;
      console.log("[GlobalCallManager] Current path for regex:", path); // More specific log
      // Simplified regex to specifically match /room/<username>/
      const match = path.match(/\/room\/([^\/]+)\/?/); // Adjusted regex for optional trailing slash
      console.log("[GlobalCallManager] Regex match result:", match); // More specific log
      return match ? match[1] : null;
    },

    // Get room name for a specific user
    getRoomNameForUser(username) {
      // This should match the Django view's _pair_room_name logic
      const currentUser = document.querySelector("strong")?.textContent || "";
      if (!currentUser || !username) return null;

      const users = [currentUser, username].sort();
      return `${users[0]}_${users[1]}`;
    },

    // Trigger call acceptance in the current room
    triggerRoomCallAcceptance() {
      // This will be called by room-specific code
      const event = new CustomEvent("globalCallAccepted", {
        detail: this.incomingCall,
      });
      window.dispatchEvent(event);
    },

    // Clean up expired calls
    cleanupExpiredCalls() {
      const state = this.getCallState();
      if (!state) return;

      // Remove calls older than 2 minutes
      if (Date.now() - state.timestamp > 120000) {
        this.endCall(); // Use endCall to ensure all resources are properly released
        this.hideGlobalCallPopup();
      }
    },
  };

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      window.GlobalCallManager.init();
    });
  } else {
    window.GlobalCallManager.init();
  }
})();
_______________________________________________________________________________________________
static/js/webrtc.js

(() => {
  "use strict";
  console.log("[WebRTC] webrtc.js loaded."); // Added log

  document.addEventListener("DOMContentLoaded", () => {
    const { roomName, wsUrl, me } = window.APP_CONTEXT;
    console.log("[WebRTC] APP_CONTEXT defined:", window.APP_CONTEXT); // Added log

    // UI refs (only chat related, call UI is managed by GlobalCallManager)
    const chatWindow = document.getElementById("chatBox");
    const messageForm = document.getElementById("messageForm");
    const messageInput = document.getElementById("messageInput");
    const btnStartCall = document.getElementById("btnStartCall");

    // GlobalCallManager references
    const GlobalCallManager = window.GlobalCallManager;

    function log(msg) {
      console.log("[WebRTC]", msg);
    }

    function appendMsg(sender, text, isMe) {
      const div = document.createElement("div");
      div.className = `msg ${isMe ? "msg--me" : "msg--peer"}`;
      div.innerHTML = `
        <div class="msg__bubble">
          <div class="msg__text">${escapeHtml(text)}</div>
          <div class="msg__time">${new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          })}</div>
        </div>
      `;
      chatWindow.appendChild(div);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function escapeHtml(s) {
      const div = document.createElement("div");
      div.appendChild(document.createTextNode(s));
      return div.innerHTML;
    }

    // WebSocket connection
    let ws;

    function connectWS() {
      ws = new WebSocket(wsUrl);
      GlobalCallManager.currentWebSocket = ws; // Set WebSocket for GlobalCallManager

      ws.onopen = async () => {
        log("WS open");
        sendWS({ type: "join" });
      };

      ws.onmessage = async (evt) => {
        const data = JSON.parse(evt.data);
        const t = data.type;
        const from = data.from;
        const to = data.to;

        // If a message is specifically for another user, ignore it in this tab
        if (to && to !== me) return;

        switch (t) {
          case "chat":
            console.log("Received chat message:", data);
            if (from && from === me) return;
            appendMsg(data.from || "Peer", data.message, false);
            if (document.hidden) {
              window.showPopup(
                "popup-message",
                `${data.from}: ${data.message}`
              );
              setTimeout(() => window.hidePopup("popup-message"), 4000);
            }
            break;

          case "offer":
            if (from === me) break;
            // Delegate incoming call handling to GlobalCallManager
            GlobalCallManager.handleIncomingCall({
              from: from,
              offer: data.offer,
              room: roomName,
            });
            // Show inline incoming call box in the current room
            const incomingBox = document.getElementById("incomingCallBox");
            const incomingText = document.getElementById("incomingCallText");
            if (incomingBox && incomingText) {
              incomingText.innerText = `${from} is calling…`;
              incomingBox.style.display = "block";
            }
            break;

          case "user_status":
            // Handle peer going offline during an active call
            const peerUsername = roomName
              .split("_")
              .find((user) => user !== me);
            if (
              data.username === peerUsername &&
              !data.is_online &&
              GlobalCallManager.currentCall &&
              GlobalCallManager.currentCall.type === "active"
            ) {
              appendMsg(
                "System",
                `${data.username} went offline. Ending call.`,
                false
              );
              GlobalCallManager.endCall();
              window.showPopup(
                "popup-message",
                `${data.username} went offline. Call ended.`
              );
              setTimeout(() => window.hidePopup("popup-message"), 4000);
            }
            // Note: chat.js also handles user_status for sidebar/header updates.
            // This case in webrtc.js is specifically for active call management.
            break;

          case "answer":
            if (from === me) break;
            if (GlobalCallManager.currentPeerConnection) {
              await GlobalCallManager.currentPeerConnection.setRemoteDescription(
                new RTCSessionDescription(data.answer)
              );
            }
            break;

          case "ice":
            if (from === me) break;
            if (GlobalCallManager.currentPeerConnection) {
              try {
                await GlobalCallManager.currentPeerConnection.addIceCandidate(
                  data.candidate
                );
              } catch (e) {
                console.error("Error adding ICE candidate:", e);
              }
            }
            break;

          case "end_call":
            appendMsg("System", `${from} ended the call`, false);
            GlobalCallManager.endCall();
            break;

          case "reject":
            appendMsg("System", `${from} rejected the call`, false);
            GlobalCallManager.endCall(); // Treat rejection as ending the call for the caller
            break;
        }
      };

      ws.onclose = () => {
        log("WS closed");
        // Reconnect after a delay
        setTimeout(connectWS, 1500);
      };

      ws.onerror = (err) => {
        console.error("WebSocket error:", err);
        ws.close();
      };
    }

    function sendWS(payload) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(payload));
      } else {
        console.warn("WebSocket not open. Message not sent:", payload);
      }
    }

    // Event listeners for chat messages
    if (messageForm) {
      messageForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const msg = messageInput.value.trim();
        if (!msg) return;
        appendMsg("You", msg, true);
        sendWS({ type: "chat", message: msg });
        messageInput.value = "";
      });
    }

    // Event listener for starting a call
    if (btnStartCall) {
      btnStartCall.addEventListener("click", async () => {
        console.log("[WebRTC] btnStartCall clicked!"); // Added log
        // Derive peerUsername from roomName and current user
        const peerUsername = roomName.split("_").find((user) => user !== me);
        if (!peerUsername) {
          console.error(
            "Cannot start call: No peer username found in roomName."
          );
          return;
        }
        console.log("[WebRTC] Peer username:", peerUsername); // Added log

        // Check if the peer is online
        if (
          window.getOnlineUsers &&
          !window.getOnlineUsers().has(peerUsername)
        ) {
          window.showPopup(
            "popup-message",
            `${peerUsername} is currently offline.`
          );
          setTimeout(() => window.hidePopup("popup-message"), 4000);
          return;
        }

        try {
          // Get local media stream
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          GlobalCallManager.setLocalStream(stream);

          // Create peer connection with ICE servers
          const pc = new RTCPeerConnection({
            iceServers: window.APP_CONTEXT.iceServers,
          });
          GlobalCallManager.currentPeerConnection = pc;

          // Add local stream tracks to peer connection
          stream.getTracks().forEach((track) => pc.addTrack(track, stream));

          // Handle ICE candidates
          pc.onicecandidate = (e) => {
            if (e.candidate) {
              sendWS({ type: "ice", to: peerUsername, candidate: e.candidate });
            }
          };

          // Handle remote tracks
          pc.ontrack = (e) => {
            GlobalCallManager.setRemoteStream(e.streams[0]);
          };

          // Create and send offer
          const offer = await pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          });
          await pc.setLocalDescription(offer);
          sendWS({ type: "offer", to: peerUsername, offer, room: roomName });

          // Update GlobalCallManager state
          GlobalCallManager.currentCall = {
            type: "active",
            peer: peerUsername,
            room: roomName,
          };
          GlobalCallManager.saveCallState(GlobalCallManager.currentCall);
          GlobalCallManager.showCallWindow();
        } catch (error) {
          console.error("Error starting call:", error);
          alert(
            "Failed to start call. Please check camera/microphone permissions."
          );
          GlobalCallManager.endCall();
        }
      });
    }

    // Listen for global call acceptance from GlobalCallManager (when navigating to a room)
    window.addEventListener("globalCallAccepted", async (event) => {
      const incomingCallData = event.detail;
      if (!incomingCallData) return;

      const peerUsername = incomingCallData.from;

      try {
        // Get local media stream
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true,
        });
        GlobalCallManager.setLocalStream(stream);

        // Create peer connection with ICE servers
        const pc = new RTCPeerConnection({
          iceServers: window.APP_CONTEXT.iceServers,
        });
        GlobalCallManager.currentPeerConnection = pc;

        // Add local stream tracks to peer connection
        stream.getTracks().forEach((track) => pc.addTrack(track, stream));

        // Handle ICE candidates
        pc.onicecandidate = (e) => {
          if (e.candidate) {
            sendWS({ type: "ice", to: peerUsername, candidate: e.candidate });
          }
        };

        // Handle remote tracks
        pc.ontrack = (e) => {
          GlobalCallManager.setRemoteStream(e.streams[0]);
        };

        // Set remote offer and create answer
        await pc.setRemoteDescription(
          new RTCSessionDescription(incomingCallData.offer)
        );
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendWS({ type: "answer", to: peerUsername, answer });

        // Update GlobalCallManager state
        GlobalCallManager.currentCall = {
          type: "active",
          peer: peerUsername,
          room: roomName,
        };
        GlobalCallManager.saveCallState(GlobalCallManager.currentCall);
        GlobalCallManager.showCallWindow();
        GlobalCallManager.hideGlobalCallPopup();
        document.getElementById("incomingCallBox").style.display = "none"; // Hide inline box
      } catch (error) {
        console.error("Error accepting global call:", error);
        alert(
          "Failed to accept call. Please check camera/microphone permissions."
        );
        GlobalCallManager.endCall();
      }
    });

    // Initial connection
    connectWS();

    // Initialize GlobalCallManager here, after APP_CONTEXT is defined
    window.GlobalCallManager.init();
  });
})();
_______________________________________________________________________________________________
videochat_app/videochat/asgi.py

import os
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "videochat.settings")

django_asgi_app = get_asgi_application()

try:
    from chat.routing import websocket_urlpatterns
except Exception:
    websocket_urlpatterns = []

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AuthMiddlewareStack(
        URLRouter(websocket_urlpatterns)
    ),
})
_______________________________________________________________________________________________
videochat_app/videochat/settings.py

from pathlib import Path
from pymongo import MongoClient
from dotenv import load_dotenv
import os

# Load environment variables from .env file
load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv("SECRET_KEY", "fallback-key")
DEBUG = os.getenv("DEBUG", "True") == "True"
ALLOWED_HOSTS = []

INSTALLED_APPS = [
    'daphne',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'chat',
    'accounts',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / "templates"],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

ROOT_URLCONF = 'videochat.urls'
ASGI_APPLICATION = 'videochat.asgi.application'

CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels.layers.InMemoryChannelLayer"
    },
}

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

STATIC_URL = 'static/'

LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/accounts/login/'

# --- MongoDB from .env ---
MONGO_URI = os.getenv("MONGO_URI", "")
MONGO_DB_NAME = os.getenv("MONGO_DB_NAME", "")

mongo_client = None
mongo_db = None

if MONGO_URI and MONGO_DB_NAME:
    try:
        mongo_client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_client.server_info()  # force connection test
        mongo_db = mongo_client[MONGO_DB_NAME]
    except Exception as e:
        print(f"[MongoDB] Connection failed: {e}")
        mongo_db = None

STATIC_URL = '/static/'
STATICFILES_DIRS = [
    BASE_DIR / "static"
]

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / "media"

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
]

# WebRTC ICE Servers (STUN/TURN)
WEBRTC_ICE_SERVERS = [
    {"urls": "stun:stun.l.google.com:19302"},
    {"urls": "stun:stun1.l.google.com:19302"},
    # Add TURN servers here if needed, e.g.:
    # {"urls": "turn:your_turn_server.com:3478", "username": "user", "credential": "password"},
]
_______________________________________________________________________________________________
videochat_app/videochat/urls.py

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('django.contrib.auth.urls')),
    path('accounts/', include('accounts.urls')),
    path('', include('chat.urls')),   # home, notifications, rooms live here
]

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
_______________________________________________________________________________________________
videochat_app/.env

SECRET_KEY=django-insecure-temp-key
DEBUG=True

# MongoDB
MONGO_URI=mongodb://localhost:27017
MONGO_DB_NAME=videochat
_______________________________________________________________________________________________
videochat_app/manage.py

#!/usr/bin/env python
import os
import sys

def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'videochat.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError("Couldn't import Django.") from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()
_______________________________________________________________________________________________


_______________________________________________________________________________________________


--- .git\COMMIT_EDITMSG ---
Initial commit - WhatsApp Clone



--- .git\config ---
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/Piyush-Puthenpurakkal/whatsapp-clone.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main



--- .git\description ---
Unnamed repository; edit this file 'description' to name the repository.



--- .git\HEAD ---
ref: refs/heads/main



--- .git\index ---
<< Could not read file: 'utf-8' codec can't decode byte 0xaf in position 13: invalid start byte >>


--- .git\hooks\applypatch-msg.sample ---
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:



--- .git\hooks\commit-msg.sample ---
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}



--- .git\hooks\fsmonitor-watchman.sample ---
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}



--- .git\hooks\post-update.sample ---
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info



--- .git\hooks\pre-applypatch.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:



--- .git\hooks\pre-commit.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --



--- .git\hooks\pre-merge-commit.sample ---
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:



--- .git\hooks\pre-push.sample ---
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0



--- .git\hooks\pre-rebase.sample ---
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END



--- .git\hooks\pre-receive.sample ---
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi



--- .git\hooks\prepare-commit-msg.sample ---
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi



--- .git\hooks\push-to-checkout.sample ---
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi



--- .git\hooks\sendemail-validate.sample ---
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi



--- .git\hooks\update.sample ---
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0



--- .git\info\exclude ---
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~



--- .git\logs\HEAD ---
0000000000000000000000000000000000000000 38619c16e941185c81b06786e43b6109d6de151b Piyush Baburaj <piyushbaburj98@gmail.com> 1756314429 +0530	commit (initial): Initial commit - WhatsApp Clone
38619c16e941185c81b06786e43b6109d6de151b 0000000000000000000000000000000000000000 Piyush Baburaj <piyushbaburj98@gmail.com> 1756314588 +0530	Branch: renamed refs/heads/master to refs/heads/main
0000000000000000000000000000000000000000 38619c16e941185c81b06786e43b6109d6de151b Piyush Baburaj <piyushbaburj98@gmail.com> 1756314588 +0530	Branch: renamed refs/heads/master to refs/heads/main



--- .git\logs\refs\heads\main ---
0000000000000000000000000000000000000000 38619c16e941185c81b06786e43b6109d6de151b Piyush Baburaj <piyushbaburj98@gmail.com> 1756314429 +0530	commit (initial): Initial commit - WhatsApp Clone
38619c16e941185c81b06786e43b6109d6de151b 38619c16e941185c81b06786e43b6109d6de151b Piyush Baburaj <piyushbaburj98@gmail.com> 1756314588 +0530	Branch: renamed refs/heads/master to refs/heads/main



--- .git\logs\refs\remotes\origin\main ---
0000000000000000000000000000000000000000 38619c16e941185c81b06786e43b6109d6de151b Piyush Baburaj <piyushbaburj98@gmail.com> 1756314593 +0530	update by push



--- .git\objects\01\064423c657dea521e17390c8f9f1c159b4ec2a ---
<< Could not read file: 'utf-8' codec can't decode byte 0xb1 in position 8: invalid start byte >>


--- .git\objects\03\022f2d4a34b94cd81a59f31347acffc2e63248 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xd0 in position 20: invalid continuation byte >>


--- .git\objects\04\13341389ad3f6a7ad0de7ed101328d18a53dd3 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte >>


--- .git\objects\04\8af0591713e97d3f22d3ff4058888280e4abe1 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte >>


--- .git\objects\05\10aa686f96489f64a66adf23cfc0a78731f1ec ---
<< Could not read file: 'utf-8' codec can't decode byte 0x90 in position 3: invalid start byte >>


--- .git\objects\09\b087b45ee0530049dc0eb2d11b43a95984bc78 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte >>


--- .git\objects\0b\b144747911fb7d0b2fec6e41d430b08471cbed ---
<< Could not read file: 'utf-8' codec can't decode byte 0x91 in position 3: invalid start byte >>


--- .git\objects\0c\c95bb74c0e0f21f5a97aeea14cb62402b80c6c ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8d in position 3: invalid start byte >>


--- .git\objects\10\b4b2922298eded58b3b833ec62088e1311c1a5 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xb5 in position 8: invalid start byte >>


--- .git\objects\12\4b9b72cb8f8ce974d897e663c544db136425d4 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xd5 in position 22: invalid continuation byte >>


--- .git\objects\15\e069e615a6cf90d8c5ad8e56139321f8000915 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte >>


--- .git\objects\1c\a883dc235a0c84b1bce9dc73f7caa5c4793648 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte >>


--- .git\objects\1d\cf2c8f3c0b33e6dead34b4e801c196192b48ee ---
<< Could not read file: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte >>


--- .git\objects\21\019ccc454558b3547b1297c291a4398e8dcd23 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte >>


--- .git\objects\32\3286445091cdaa2ad0a99b2b737d65058c4c77 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte >>


--- .git\objects\32\58827e43de63560a4ccceacf1c88dd9559bab9 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte >>


--- .git\objects\34\f6c3ef2409cef059cfec44b830331e8ed2d99f ---
<< Could not read file: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte >>


--- .git\objects\38\619c16e941185c81b06786e43b6109d6de151b ---
<< Could not read file: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte >>


--- .git\objects\3e\3c76595bcab116bb99a1722e542e07cdd23c71 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xcc in position 3: invalid continuation byte >>


--- .git\objects\3e\bee0311cdb47fb4785ba222683e7c7571800f8 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8f in position 5: invalid start byte >>


--- .git\objects\40\f509d6d41dadedf2fa1cb30abbb9007fd0c81a ---
<< Could not read file: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte >>


--- .git\objects\47\1f50868dd88b575e789f46540d749b829c4df1 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x90 in position 3: invalid start byte >>


--- .git\objects\50\96916d565ef36b745c7f2577ca79a846c41147 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte >>


--- .git\objects\51\d56d4046cd9306fa17f5b104acbfd6db5a1afe ---
<< Could not read file: 'utf-8' codec can't decode byte 0xd0 in position 18: invalid continuation byte >>


--- .git\objects\53\cbd73200e7635967268d7c633f91b577bad2d4 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xb1 in position 9: invalid start byte >>


--- .git\objects\57\dd86ff821935b5506a9006b4c5acfc3e127396 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xc8 in position 17: invalid continuation byte >>


--- .git\objects\5a\2530bc93f7f04d47042a24e8df0bf1f2a436a2 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xce in position 19: invalid continuation byte >>


--- .git\objects\5c\30a1fc5459fe5c33ebff16cf58e1e2a364ff90 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xcb in position 4: invalid continuation byte >>


--- .git\objects\60\505c3343c24f99aa14dd9b73f1252155683da5 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xc3 in position 6: invalid continuation byte >>


--- .git\objects\61\83d22339b3a508727c878ccc12a54ed053e063 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xc3 in position 6: invalid continuation byte >>


--- .git\objects\63\86eb2a65d01e1fbda04b831544ac3b0ed2667c ---
<< Could not read file: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte >>


--- .git\objects\6b\9430204a796ba1c24c6c359d0813e3cb070235 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xb0 in position 7: invalid start byte >>


--- .git\objects\72\c755d6f9727534469211f07f48dfdb4f4b6238 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte >>


--- .git\objects\7c\e503c2dd97ba78597f6ff6e4393132753573f6 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte >>


--- .git\objects\84\7d271a63f1421ffcb407d49ed329bd7e37065a ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8d in position 3: invalid start byte >>


--- .git\objects\87\81329b5b140666fb2be70d2680e5ccd4e463a3 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xcf in position 23: invalid continuation byte >>


--- .git\objects\8c\38f3f3dad51e4585f3984282c2a4bec5349c1e ---
<< Could not read file: 'utf-8' codec can't decode byte 0xc1 in position 3: invalid start byte >>


--- .git\objects\8e\c6f9dd25b1c145c84fd9b07ac6ec4a570f7abc ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte >>


--- .git\objects\a5\a2311fb95774bf4d606130da82959c8fb066ae ---
<< Could not read file: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte >>


--- .git\objects\ab\46bb887eca585a22ca77937f155f6f423ddcad ---
<< Could not read file: 'utf-8' codec can't decode byte 0x90 in position 3: invalid start byte >>


--- .git\objects\ab\f33db116ca74637965d2fe9f8d852fbd6e78a1 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x85 in position 2: invalid start byte >>


--- .git\objects\b9\78def2c24c9c354b85748611dceacf74454b92 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xe5 in position 2: invalid continuation byte >>


--- .git\objects\ba\423138c7e646ff11a07a21a14b3c0e8d562f31 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x92 in position 3: invalid start byte >>


--- .git\objects\be\45ba9eff1cd38667e8829f814fb1592b1d0e10 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte >>


--- .git\objects\c1\f861592a48c4d85f3f9a126ea5181bdabc54ef ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8d in position 22: invalid start byte >>


--- .git\objects\c3\42047c7a7f34f8b9477a4786e87952b0cd8f07 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte >>


--- .git\objects\c3\cf945de68eeacf9f004588ee5de35ad1a1cab0 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8c in position 3: invalid start byte >>


--- .git\objects\cc\3099500761bf6523affa82d03fcb37afcfe8b6 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte >>


--- .git\objects\ce\7a2d12142e15112219e236722ebe2ad6056857 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte >>


--- .git\objects\d3\2d8216f9f61f4fed228a4c3ad20419de16b19c ---
<< Could not read file: 'utf-8' codec can't decode byte 0xa5 in position 2: invalid start byte >>


--- .git\objects\d4\f88b83c1c7b25b7e54c90541b818ba1a7225f8 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xb5 in position 2: invalid start byte >>


--- .git\objects\e6\9de29bb2d1d6434b8b29ae775ad8c2e48c5391 ---
<< Could not read file: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte >>


--- .git\objects\f4\6f9593262f117f12928e9d40cc4e26f1ee01b8 ---
<< Could not read file: 'utf-8' codec can't decode byte 0x8d in position 3: invalid start byte >>


--- .git\objects\f6\4ead844963bcea63e002c239404f4439af4e8e ---
<< Could not read file: 'utf-8' codec can't decode byte 0xe3 in position 9: invalid continuation byte >>


--- .git\objects\fa\c523fbb1b811f84b0a7d879149ebc96a69c81e ---
<< Could not read file: 'utf-8' codec can't decode byte 0xc5 in position 2: invalid continuation byte >>


--- .git\refs\heads\main ---
38619c16e941185c81b06786e43b6109d6de151b



--- .git\refs\remotes\origin\main ---
38619c16e941185c81b06786e43b6109d6de151b



--- accounts\admin.py ---
from django.contrib import admin

# Register your models here.



--- accounts\apps.py ---
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'



--- accounts\forms.py ---
from django import forms
from django.contrib.auth.forms import UserCreationForm
from .models import CustomUser

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(required=True)

    class Meta:
        model = CustomUser
        fields = ("username", "email",) # UserCreationForm automatically adds password fields

    def save(self, commit=True):
        user = super().save(commit=False)
        user.email = self.cleaned_data["email"]
        if commit:
            user.save()
        return user



--- accounts\models.py ---
from django.db import models
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    email_verified = models.BooleanField(default=False)

    def __str__(self):
        return self.username



--- accounts\tests.py ---
from django.test import TestCase

# Create your tests here.



--- accounts\urls.py ---
from django.urls import path, include
from django.contrib.auth import views as auth_views
from .views import SignUpView, activate, CustomLoginView
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    path('signup/', SignUpView.as_view(), name='signup'),
    path('login/', CustomLoginView.as_view(), name='login'),
    path('activate/<uidb64>/<token>/', activate, name='activate'),
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('password_reset/', auth_views.PasswordResetView.as_view(template_name='registration/password_reset_form.html'), name='password_reset'),
    path('password_reset/done/', auth_views.PasswordResetDoneView.as_view(template_name='registration/password_reset_done.html'), name='password_reset_done'),
    path('reset/<uidb64>/<token>/', auth_views.PasswordResetConfirmView.as_view(template_name='registration/password_reset_confirm.html'), name='password_reset_confirm'),
    path('reset/done/', auth_views.PasswordResetCompleteView.as_view(template_name='registration/password_reset_complete.html'), name='password_reset_complete'),
]



--- accounts\views.py ---
from django.urls import reverse_lazy, reverse
from django.views import generic
from django.contrib import messages
from django.contrib.auth import get_user_model
from django.contrib.auth.tokens import default_token_generator
from django.utils.encoding import force_bytes
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.core.mail import EmailMessage
from django.template.loader import render_to_string
from django.shortcuts import render, redirect
from django.utils.html import mark_safe
from django.conf import settings
from chat.mongo import get_db
from datetime import datetime
from .forms import CustomUserCreationForm
from django.contrib.auth.views import LoginView
from django_ratelimit.decorators import ratelimit
from django.apps import apps
from django.contrib.auth import get_user_model
from rest_framework_simplejwt.tokens import RefreshToken # Import RefreshToken

class CustomLoginView(LoginView):
    template_name = 'registration/login.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Add an empty token to the context by default
        context['access_token'] = None
        return context

    def form_valid(self, form):
        response = super().form_valid(form)
        user = form.get_user()
        if user:
            refresh = RefreshToken.for_user(user)
            access_token = str(refresh.access_token)
            # Pass the access token to the template context
            redirect_url = reverse('home')
            response = redirect(redirect_url)
            # Set the access token in an HTTP-only cookie for security
            response.set_cookie(
                key=settings.SIMPLE_JWT['AUTH_COOKIE'],
                value=access_token,
                expires=settings.SIMPLE_JWT['ACCESS_TOKEN_LIFETIME'],
                secure=settings.SIMPLE_JWT['AUTH_COOKIE_SECURE'],
                httponly=settings.SIMPLE_JWT['AUTH_COOKIE_HTTP_ONLY'],
                samesite=settings.SIMPLE_JWT['AUTH_COOKIE_SAMESITE']
            )
        return response

    def dispatch(self, request, *args, **kwargs):
        # Ensure the correct user model is used for authentication
        self.model = get_user_model()
        return super().dispatch(request, *args, **kwargs)

class SignUpView(generic.CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/signup.html'

    def form_valid(self, form):
        user = form.save(commit=False)
        user.is_active = False  # Deactivate account until email is verified
        user.save()

        try:
            db = get_db()
            db.users.insert_one({
                "username": user.username,
                "email": user.email,
                "date_joined": datetime.utcnow(),
                "email_verified": False,
            })
        except Exception as e:
            messages.warning(self.request, f"Account created, but failed to save in MongoDB: {e}")

        # Send verification email
        current_site = self.request.get_host()
        mail_subject = 'Activate your account.'
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = default_token_generator.make_token(user)
        activation_link = self.request.build_absolute_uri(
            reverse_lazy('activate', kwargs={'uidb64': uid, 'token': token})
        )
        message = render_to_string('accounts/acc_active_email.html', {
            'user': user,
            'domain': current_site,
            'uid': uid,
            'token': token,
            'activation_link': activation_link,
        })
        to_email = form.cleaned_data.get('email')
        email = EmailMessage(
            mail_subject, message, to=[to_email]
        )
        email.send()

        messages.success(self.request, mark_safe("Please confirm your email address to complete the registration. Check your inbox and spam folder."))
        return redirect('login')

def activate(request, uidb64, token):
    try:
        uid = urlsafe_base64_decode(uidb64).decode()
        User = apps.get_model('accounts', 'CustomUser')
        user = User._default_manager.get(pk=uid)
    except (TypeError, ValueError, OverflowError, User.DoesNotExist):
        user = None

    if user is not None and default_token_generator.check_token(user, token):
        user.is_active = True
        user.email_verified = True # Assuming a new field `email_verified` in CustomUser
        user.save()
        try:
            db = get_db()
            db.users.update_one(
                {"username": user.username},
                {"$set": {"email_verified": True}}
            )
        except Exception as e:
            messages.warning(request, f"Email verified, but failed to update in MongoDB: {e}")
        messages.success(request, 'Thank you for your email confirmation. Now you can log in to your account.')
        return redirect('login')
    else:
        messages.error(request, 'Activation link is invalid!')
        return redirect('login')



--- accounts\__init__.py ---



--- accounts\migrations\0001_initial.py ---
# Generated by Django 5.2.5 on 2025-08-24 18:56

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email_verified', models.BooleanField(default=False)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]



--- accounts\migrations\__init__.py ---



--- accounts\templates\accounts\acc_active_email.html ---
{% autoescape off %} Hi {{ user.username }}, Please click on the link to confirm
your registration: {{ activation_link }} {% endautoescape %}


--- accounts\templates\registration\password_reset_complete.html ---
{% extends "base_auth.html" %} {% block title %}Password Reset Complete{%
endblock %} {% block content %}
<div class="auth-container">
  <h2>Password Reset Complete</h2>
  <p>Your password has been set. You may go ahead and log in now.</p>
  <p><a href="{% url 'login' %}" class="btn btn-primary">Log in</a></p>
</div>
{% endblock %}



--- accounts\templates\registration\password_reset_confirm.html ---
{% extends "base_auth.html" %} {% block title %}Set New Password{% endblock %}
{% block content %}
<div class="auth-container">
  <h2>Set a New Password</h2>
  {% if validlink %}
  <p>
    Please enter your new password twice so we can verify you typed it in
    correctly.
  </p>
  <form method="post">
    {% csrf_token %} {{ form.as_p }}
    <button type="submit" class="btn btn-primary">Set new password</button>
  </form>
  {% else %}
  <p>
    The password reset link was invalid, possibly because it has already been
    used. Please request a new password reset.
  </p>
  {% endif %}
</div>
{% endblock %}



--- accounts\templates\registration\password_reset_done.html ---
{% extends "base_auth.html" %} {% block title %}Password Reset Done{% endblock
%} {% block content %}
<div class="auth-container">
  <h2>Password Reset Sent</h2>
  <p>
    We've emailed you instructions for setting your password, if an account
    exists with the email you entered. You should receive them shortly.
  </p>
  <p>
    If you don't receive an email, please make sure you've entered the address
    you registered with, and check your spam folder.
  </p>
</div>
{% endblock %}



--- accounts\templates\registration\password_reset_form.html ---
{% extends "base_auth.html" %} {% block title %}Password Reset{% endblock %} {%
block content %}
<div class="auth-container">
  <h2>Reset Your Password</h2>
  <p>
    Forgotten your password? Enter your email address below, and we'll email you
    instructions for setting a new one.
  </p>
  <form method="post">
    {% csrf_token %} {{ form.as_p }}
    <button type="submit" class="btn btn-primary">Reset my password</button>
  </form>
</div>
{% endblock %}



--- chat\consumers.py ---
import json
from datetime import datetime
import redis.asyncio as redis
import os
from bson.objectid import ObjectId # Added for MongoDB ObjectId

from asgiref.sync import sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.conf import settings
from django.contrib.auth import get_user_model # Added get_user_model
from webpush import send_user_notification # Assuming webpush is installed

from .mongo import get_db
from chat.views import _pair_room_name # Import _pair_room_name
import json
from datetime import datetime
import redis.asyncio as redis
import os
from bson.objectid import ObjectId # Added for MongoDB ObjectId

from asgiref.sync import sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.conf import settings
from django.contrib.auth import get_user_model # Added get_user_model
from webpush import send_user_notification # Assuming webpush is installed

from .mongo import get_db
from chat.views import _pair_room_name # Import _pair_room_name

# Initialize Redis client
redis_client = redis.from_url(os.getenv("REDIS_URL", "redis://localhost:6379/0"))

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_name = self.scope["url_route"]["kwargs"]["room_name"]
        self.room_group_name = f"chat_{self.room_name}"

        user = self.scope.get("user")
        self.username = (
            str(user.username) if getattr(user, "is_authenticated", False) else "Anonymous"
        )
        print(f"[ChatConsumer] User connected: {self.username}, Authenticated: {getattr(user, 'is_authenticated', False)}") # Debugging

        # Add user to a specific group for direct messaging (if needed, otherwise room_group_name is enough)
        self.user_channel_name = f"user_{self.username}"
        await self.channel_layer.group_add(self.user_channel_name, self.channel_name)

        await self.channel_layer.group_add(self.room_group_name, self.channel_name)
        await self.channel_layer.group_add("global_presence", self.channel_name) # Add to global presence group
        await self.accept()

        # Add user to online users set in Redis and broadcast status
        if self.username != "Anonymous":
            print(f"[ChatConsumer] Adding {self.username} to online_users Redis set.") # Debugging
            await redis_client.sadd("online_users", self.username)
            await self.broadcast_user_status(self.username, True)

            # Send the current list of online users to the newly connected user
            online_users_list = await self.get_online_users()
            print(f"[ChatConsumer] Sending online_users_list to {self.username}: {online_users_list}") # Debugging
            await self.send(text_data=json.dumps({
                "type": "online_users_list",
                "users": online_users_list,
            }))

        try:
            join_msg = {
                "type": "join",
                "from": self.username,
                "event_type": "join",
                "sender": self.username,
            }
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "room_event", "message": join_msg},
            )
        except Exception:
            pass

    async def disconnect(self, close_code):
        print(f"[ChatConsumer] User {self.username} disconnected from room {self.room_name} with code {close_code}")

        await self.channel_layer.group_discard(self.room_group_name, self.channel_name)
        await self.channel_layer.group_discard(self.user_channel_name, self.channel_name)
        await self.channel_layer.group_discard("global_presence", self.channel_name) # Discard from global presence group

        # Remove user from online users set in Redis and broadcast status
        if self.username != "Anonymous":
            print(f"[ChatConsumer] Removing {self.username} from online_users Redis set.")
            await redis_client.srem("online_users", self.username)
            await self.broadcast_user_status(self.username, False)

        try:
            leave_msg = {
                "type": "leave",
                "from": self.username,
                "event_type": "leave",
                "sender": self.username,
            }
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "room_event", "message": leave_msg},
            )
        except Exception:
            pass

    async def broadcast_user_status(self, username, is_online):
        """Broadcasts a user's online/offline status to all relevant groups."""
        status_message = {
            "type": "user_status",
            "username": username,
            "is_online": is_online,
        }
        await self.channel_layer.group_send(
            "global_presence",
            {"type": "send_user_status", "message": status_message},
        )

    async def send_user_status(self, event):
        """Handles the 'send_user_status' event to send status updates to the websocket."""
        message = event["message"]
        await self.send(text_data=json.dumps(message))

    async def get_online_users(self):
        """Returns the list of currently online users from Redis."""
        online_users_bytes = await redis_client.smembers("online_users")
        online_users_list = [user.decode('utf-8') for user in online_users_bytes]
        print(f"[ChatConsumer] Current online users in Redis: {online_users_list}") # Debugging
        return online_users_list

    async def receive(self, text_data=None, bytes_data=None):
        if not text_data:
            return

        try:
            data = json.loads(text_data)
        except Exception:
            return

        msg_type = data.get("type")
        payload = {k: v for k, v in data.items() if k != "type"}
        sender = self.username

        out = {
            "type": msg_type,
            "from": sender,
            "event_type": msg_type,
            "sender": sender,
            **payload,
        }

        db = get_db()
        if db is not None:
            try:
                if msg_type == "chat":
                    recipient_username = payload.get("recipient")
                    # Determine the correct room name for saving based on sender and recipient
                    chat_room_name = _pair_room_name(sender, recipient_username)

                    doc = {
                        "room": chat_room_name, # Use the derived chat_room_name for saving
                        "sender": sender,
                        "message": payload.get("message", ""),
                        "timestamp": datetime.utcnow().isoformat(), # Convert to ISO 8601 string
                        "read": False, # For read receipts
                    }
                    print(f"[DEBUG chat/consumers.py] Attempting to save message to MongoDB for room: {chat_room_name}")
                    print(f"[DEBUG chat/consumers.py] Message doc: {doc}")
                    result = await sync_to_async(db.chats.insert_one)(doc)
                    out["message_id"] = str(result.inserted_id) # Add the message ID
                    out["timestamp"] = doc["timestamp"] # Add timestamp to the broadcast message
                    out["read"] = doc["read"] # Add read status to the broadcast message
                    out["temp_message_id"] = payload.get("temp_message_id") # Pass temp ID back to client
                    print(f"[DEBUG chat/consumers.py] Message saved with ID: {out['message_id']}")

                    # Send push notification for new chat message
                    if sender != self.room_name: # Only send if not a self-message in a 1-1 chat
                        await self.send_push_notification(
                            recipient_username=self.room_name, # Assuming room_name is the peer's username in 1-1 chat
                            title=f"New message from {sender}",
                            body=payload.get("message", ""),
                            url=f"/chat/room/{sender}/" # Link to the chat room
                        )

                elif msg_type in (
                    "offer", "answer", "ice",
                    "call", "missed_call",
                    "end_call", "reject"
                ):
                    recipient = payload.get("to_user")
                    doc = {
                        "room": self.room_name,
                        "sender": sender,
                        "recipient": recipient,
                        "type": msg_type,
                        "payload": payload,
                        "timestamp": datetime.utcnow(),
                        "read": False,
                    }
                    await sync_to_async(db.notifications.insert_one)(doc)
                    # Send push notification for call events
                    if recipient:
                        notification_body = ""
                        notification_url = "/"
                        if msg_type == "call":
                            notification_body = f"Incoming call from {sender}"
                            notification_url = f"/chat/room/{sender}/" # Link to the call room
                        elif msg_type == "missed_call":
                            notification_body = f"Missed call from {sender}"
                            notification_url = f"/chat/room/{sender}/"
                        
                        if notification_body:
                            await self.send_push_notification(
                                recipient_username=recipient,
                                title="VideoChat Call",
                                body=notification_body,
                                url=notification_url
                            )

                elif msg_type == "typing":
                    # Broadcast typing indicator to the room, excluding the sender
                    await self.channel_layer.group_send(
                        self.room_group_name,
                        {
                            "type": "typing_indicator",
                            "username": sender,
                            "is_typing": payload.get("is_typing"),
                        }
                    )
                    return # Don't save typing indicators to DB

                elif msg_type == "read_receipt":
                    message_id = payload.get("message_id")
                    if message_id:
                        await sync_to_async(db.chats.update_one)(
                            {"_id": ObjectId(message_id)},
                            {"$set": {"read": True, "read_at": datetime.utcnow()}}
                        )
                        # Broadcast the read receipt update to the sender's channel
                        await self.channel_layer.group_send(
                            self.user_channel_name,
                            {"type": "room_event", "message": {"type": "read_receipt_update", "message_id": message_id}},
                        )
                    return # Don't broadcast read receipts globally, handle client-side

            except Exception as e:
                print(f"[MongoDB] save failed: {e}")

        # Determine if the message should be sent to a specific user or broadcast
        to_user = data.get("to")
        if msg_type == "get_online_users":
            online_users_list = await self.get_online_users()
            await self.send(text_data=json.dumps({
                "type": "online_users_list",
                "users": online_users_list,
            }))
        elif msg_type == "chat":
            recipient_username = payload.get("recipient")
            
            # Send to sender's channel for immediate display and confirmation
            await self.channel_layer.group_send(
                self.user_channel_name,
                {"type": "room_event", "message": out},
            )
            
            # Send to recipient's channel if specified and not the sender
            if recipient_username and recipient_username != self.username:
                await self.channel_layer.group_send(
                    f"user_{recipient_username}",
                    {"type": "room_event", "message": out},
                )
            # Also send to the room group for general chat if it's a group chat,
            # or if we want all participants in a 1-1 chat to receive it via room_group_name
            # (though direct user_channel_name is more precise for 1-1)
            # For now, let's assume 1-1 chat and direct sending is sufficient.
            # If group chats are intended, this logic might need adjustment.
        elif to_user:
            # Send directly to the target user's channel for other message types
            await self.channel_layer.group_send(
                f"user_{to_user}",
                {"type": "room_event", "message": out},
            )
        else:
            # Broadcast to the entire room group for other message types (e.g., group calls)
            await self.channel_layer.group_send(
                self.room_group_name,
                {"type": "room_event", "message": out},
            )

    async def send_push_notification(self, recipient_username, title, body, url):
        db = get_db()
        if db is not None:
            try:
                # Get the recipient user object
                RecipientUser = await database_sync_to_async(get_user_model().objects.get)(username=recipient_username)

                # Find the recipient's subscription from MongoDB
                subscription_doc = await sync_to_async(db.subscriptions.find_one)(
                    {"user_id": RecipientUser.id} # Use recipient's user_id
                )
                if subscription_doc and subscription_doc.get("subscription"):
                    subscription_info = subscription_doc["subscription"]
                    payload = {"head": title, "body": body, "url": url}
                    await sync_to_async(send_user_notification)(
                        user=RecipientUser, # Pass the Django recipient user object
                        payload=payload,
                        vapid_private_key=settings.VAPID_PRIVATE_KEY,
                        vapid_admin_email=settings.VAPID_ADMIN_EMAIL,
                        push_subscription=subscription_info
                    )
            except Exception as e:
                print(f"[WebPush] Failed to send push notification: {e}")

    async def typing_indicator(self, event):
        """Handles the 'typing_indicator' event to send typing status to the websocket."""
        username = event["username"]
        is_typing = event["is_typing"]
        if username != self.username: # Don't send typing indicator back to the sender
            await self.send(text_data=json.dumps({
                "type": "typing_indicator",
                "username": username,
                "is_typing": is_typing,
            }))

    async def room_event(self, event):
        message = event.get("message", {})
        try:
            await self.send(text_data=json.dumps(message))
        except Exception:
            pass



--- chat\mongo.py ---
import os
from pymongo import MongoClient
from django.conf import settings

_client = None
_db = None

def _init():
    global _client, _db
    uri = getattr(settings, "MONGO_URI", "") or os.getenv("MONGO_URI", "")
    dbname = getattr(settings, "MONGO_DB_NAME", "") or os.getenv("MONGO_DB_NAME", "")
    if uri and dbname:
        try:
            _client = MongoClient(uri, serverSelectionTimeoutMS=3000)
            _client.server_info()
            _db = _client[dbname]

            # Create indexes for chats collection
            _db.chats.create_index([("room", 1), ("timestamp", 1)])
            # Create indexes for notifications collection
            _db.notifications.create_index([("room", 1), ("timestamp", 1)])
            _db.notifications.create_index([("recipient", 1), ("timestamp", 1)]) # For user-specific notifications

        except Exception as e:
            print(f"[MongoDB] connection failed: {e}")
            _client = None
            _db = None

def get_db():
    global _db
    if _db is None:
        _init()
    return _db



--- chat\routing.py ---
from django.urls import re_path
from .consumers import ChatConsumer

websocket_urlpatterns = [
    re_path(r"^ws/chat/(?P<room_name>[^/]+)/$", ChatConsumer.as_asgi()),
]



--- chat\urls.py ---
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('notifications/', views.notifications, name='notifications'),
    path('room/<str:username>/', views.room_with_user, name='room_with_user'),
    path('call/<str:username>/', views.room_with_user, name='call_user'),  # legacy alias
    path('subscribe_push/', views.subscribe_push, name='subscribe_push'),
]



--- chat\views.py ---
from django.contrib.auth.decorators import login_required
from django.contrib.auth import get_user_model
from django.shortcuts import render, get_object_or_404
from django.http import Http404, JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings # Import settings
from chat.mongo import get_db
import json

User = get_user_model()

def _pair_room_name(a, b):
    a, b = sorted([a, b])
    return f"{a}_{b}"

@login_required
def home(request):
    users = User.objects.exclude(id=request.user.id).order_by("username")
    return render(request, "chat/home.html", {"users": users})

@login_required
def room_with_user(request, username):
    peer = get_object_or_404(User, username=username)
    if peer.id == request.user.id:
        raise Http404("Cannot call yourself.")

    print(f"[DEBUG chat/views.py] Current user: {request.user.username}, Peer: {peer.username}")
    room_name = _pair_room_name(request.user.username, peer.username)
    print(f"[DEBUG chat/views.py] Generated room_name: {room_name}")

    # preload last 50 chat messages from Mongo (if available)
    history = []
    db = get_db()
    if db is not None:
        try:
            print(f"[DEBUG chat/views.py] Querying MongoDB for room: {room_name}")
            cur = db.chats.find({"room": room_name}).sort("timestamp", -1).limit(50)
            for msg in reversed(list(cur)):
                msg['id'] = str(msg['_id']) # Convert ObjectId to string and map to 'id' for template
                # Convert timestamp string back to datetime object for Django template filter
                if 'timestamp' in msg and isinstance(msg['timestamp'], str):
                    from datetime import datetime
                    msg['timestamp'] = datetime.fromisoformat(msg['timestamp'])
                history.append(msg)
            print(f"[DEBUG chat/views.py] Fetched {len(history)} messages from MongoDB for room {room_name}.")
            # print(f"[DEBUG chat/views.py] History: {history}") # Uncomment for full history dump if needed
        except Exception as e:
            print(f"[MongoDB] fetch history failed: {e}")
            print(f"[MongoDB] Error details: {e}")

    users = User.objects.exclude(id=request.user.id).order_by("username")
    return render(
        request,
        "chat/room.html",
        {
            "peer": peer,
            "room_name": room_name,
            "history": history,
            "users": users,
            "webrtc_ice_servers": settings.WEBRTC_ICE_SERVERS, # Pass ICE servers to template
        },
    )

@login_required
def notifications(request):
    logs = []
    db = get_db()
    if db is not None:
        try:
            # Fetch notifications where the current user is the recipient
            cursor = db.notifications.find({"recipient": request.user.username}).sort("timestamp", -1).limit(50)
            logs = list(cursor)
        except Exception as e:
            print(f"[MongoDB] fetch notifications failed: {e}")
    return render(request, "chat/notifications.html", {"logs": logs})

@require_POST
@csrf_exempt
@login_required
def subscribe_push(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            subscription = data['subscription']
            user_id = request.user.id

            db = get_db()
            if db:
                db.subscriptions.update_one(
                    {"user_id": user_id},
                    {"$set": {"subscription": subscription}},
                    upsert=True
                )
                return JsonResponse({"message": "Subscription saved successfully."})
            else:
                return JsonResponse({"error": "MongoDB not connected."}, status=500)
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=400)
    return JsonResponse({"error": "Invalid request method."}, status=405)



--- chat\__init__.py ---



--- chat\templates\base_auth.html ---
{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block title %}Auth{% endblock %}</title>
    <link rel="stylesheet" href="{% static 'css/base_auth.css' %}" />
  </head>

  <body>
    <div class="auth-container">
      <div class="auth-header">
        <button
          id="login-tab"
          class="{% if request.resolver_match.url_name == 'login' %}active{% endif %}"
          onclick="location.href='{% url 'login' %}'"
        >
          Login
        </button>
        <button
          id="signup-tab"
          class="{% if request.resolver_match.url_name == 'signup' %}active{% endif %}"
          onclick="location.href='{% url 'signup' %}'"
        >
          Sign Up
        </button>
      </div>
      <div class="auth-content">{% block content %}{% endblock %}</div>
    </div>
  </body>
</html>



--- chat\templates\chat\base.html ---
{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>{% block title %}VideoChat{% endblock %}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="{% static 'css/app.css' %}" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  {% block extra_head %}{% endblock %}
</head>

<body>
  <!-- TOPBAR -->
  <header class="topbar">
    <div class="topbar__left">
      <a href="/" class="brand">WhatsApp Clone</a>
    </div>
    <div class="topbar__right">
      <span class="whoami">Hi, <strong>{{ request.user.username }}</strong></span>
      <a class="btn btn-ghost" href="{% url 'notifications' %}"><i class="fas fa-bell"></i></a>
      <a class="btn btn-ghost" href="/"><i class="fas fa-home"></i></a>
      <button id="themeToggle" class="btn btn-ghost">
        <i class="fas fa-moon"></i>
      </button>
      <!-- Safe logout via POST -->
      <form id="logoutForm" method="post" action="{% url 'logout' %}" class="logout-form">
        {% csrf_token %}
        <button type="submit" class="btn btn-ghost">
          <i class="fas fa-sign-out-alt"></i>
        </button>
      </form>
    </div>
  </header>

  <!-- WORKSPACE -->
  <main class="workspace">
    <aside id="sidebarPane" class="pane pane--left">
      <div class="sidebar">
        <div class="sidebar__header">
          <div class="avatar">{{ request.user.username|first|upper }}</div>
          <div class="actions">
            <button class="btn btn-ghost">
              <i class="fas fa-circle-notch"></i>
            </button>
            <button class="btn btn-ghost">
              <i class="fas fa-comment-alt"></i>
            </button>
            <button class="btn btn-ghost">
              <i class="fas fa-ellipsis-v"></i>
            </button>
            <button id="closeSidebarBtn" class="btn btn-ghost d-none">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <div class="sidebar__search">
          <input type="text" placeholder="Search or start new chat" />
        </div>
        <ul class="chat-list">
          {% block sidebar %}{% endblock %}
        </ul>
      </div>
    </aside>
    <section class="pane pane--right">
      <button id="sidebarToggle" class="btn btn-ghost sidebar-toggle">
        <i class="fas fa-bars"></i>
      </button>
      {% block content %}
      <div class="empty-state">
        <h2>Welcome to WhatsApp Clone</h2>
        <p>Click on a chat to start messaging or start a new one.</p>
      </div>
      {% endblock %}
    </section>
  </main>

  <!-- POPUPS -->
  <div id="popup-message" class="popup">
    <h4>New Message</h4>
    <p id="popup-message-text"></p>
    <div class="actions">
      <button class="btn btn-ghost" onclick="hidePopup('popup-message')">
        Close
      </button>
    </div>
  </div>
  <div id="popup-call" class="popup">
    <h4>Incoming Call</h4>
    <p id="popup-call-text"></p>
    <div class="actions">
      <button id="btnAcceptCall" class="btn btn-primary">
        <i class="fas fa-phone"></i> Accept
      </button>
      <button id="btnRejectCall" class="btn btn-danger">
        <i class="fas fa-phone-slash"></i> Reject
      </button>
    </div>
  </div>

  <script>
    // popup helpers
    function showPopup(id, text) {
      const t = document.getElementById(id + "-text");
      if (t) t.innerText = text || "";
      document.getElementById(id).style.display = "block";
    }
    function hidePopup(id) {
      document.getElementById(id).style.display = "none";
    }

    // Define APP_CONTEXT for global scripts
    window.APP_CONTEXT = {
      me: "{{ request.user.username|escapejs }}",
      // wsUrl will be defined dynamically in chat.js or overridden in room.html
    };

    // Theme Toggle Logic
    const themeToggleBtn = document.getElementById('themeToggle');
    const currentTheme = localStorage.getItem('theme');

    function applyTheme(theme) {
      document.body.classList.toggle('light-theme', theme === 'light');
      themeToggleBtn.querySelector('i').className = theme === 'light' ? 'fas fa-sun' : 'fas fa-moon';
    }

    if (currentTheme) {
      applyTheme(currentTheme);
    } else {
      // Default to dark theme if no preference is set
      applyTheme('dark');
    }

    themeToggleBtn.addEventListener('click', () => {
      const newTheme = document.body.classList.contains('light-theme') ? 'dark' : 'light';
      localStorage.setItem('theme', newTheme);
      applyTheme(newTheme);
    });

    // Responsive Sidebar Logic
    const sidebarPane = document.getElementById('sidebarPane');
    const sidebarToggleBtn = document.getElementById('sidebarToggle');

    function toggleSidebar() {
      sidebarPane.classList.toggle('is-open');
    }

    if (sidebarToggleBtn) {
      sidebarToggleBtn.addEventListener('click', toggleSidebar);
    }

    // Close sidebar on larger screens if it was opened on mobile
    window.addEventListener('resize', () => {
      if (window.innerWidth > 768 && sidebarPane.classList.contains('is-open')) {
        sidebarPane.classList.remove('is-open');
      }
    });
  </script>
  <script>
    // Read accessToken from URL query parameter and move to localStorage
    const urlParams = new URLSearchParams(window.location.search);
    const tokenFromUrl = urlParams.get('token');

    if (tokenFromUrl) {
      localStorage.setItem('accessToken', tokenFromUrl);
      console.log("[base.html] Moved accessToken from URL to localStorage.");

      // Remove token from URL to prevent it from being exposed in browser history/logs
      urlParams.delete('token');
      const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
      window.history.replaceState({}, document.title, newUrl);
    }
  </script>
  {% block scripts %}{% endblock %}
  <script>
    // Event listeners for global call popup
    document.getElementById("btnAcceptCall").addEventListener("click", () => {
      window.GlobalCallManager.acceptCall();
    });

    document.getElementById("btnRejectCall").addEventListener("click", () => {
      window.GlobalCallManager.rejectCall();
    });

    // Web Push Notification Registration
    const VAPID_PUBLIC_KEY = "{{ settings.VAPID_PUBLIC_KEY }}";

    function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - base64String.length % 4) % 4);
      const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

      const rawData = window.atob(base64);
      const outputArray = new Uint8Array(rawData.length);

      for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    if ('serviceWorker' in navigator && 'PushManager' in window) {
      navigator.serviceWorker.register('{% static "js/webpush_serviceworker.js" %}')
        .then(function (registration) {
          console.log('Service Worker Registered', registration);

          registration.pushManager.getSubscription()
            .then(function (subscription) {
              if (subscription) {
                console.log('Already subscribed', subscription);
                // You might want to send this subscription to your backend if it's not there
              } else {
                const applicationServerKey = urlBase64ToUint8Array(VAPID_PUBLIC_KEY);
                registration.pushManager.subscribe({
                  userVisibleOnly: true,
                  applicationServerKey: applicationServerKey
                })
                  .then(function (newSubscription) {
                    console.log('New Push Subscription:', newSubscription);
                    // Send subscription to your backend
                    fetch('{% url "subscribe_push" %}', {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                      },
                      body: JSON.stringify({ subscription: newSubscription.toJSON() })
                    })
                      .then(response => response.json())
                      .then(data => console.log('Subscription saved on server:', data))
                      .catch(error => console.error('Error saving subscription:', error));
                  })
                  .catch(function (error) {
                    console.error('Failed to subscribe the user: ', error);
                  });
              }
            });
        })
        .catch(function (error) {
          console.error('Service Worker registration failed: ', error);
        });
    }
  </script>

</body>

</html>


--- chat\templates\chat\home.html ---
{% extends "chat/base.html" %} {% block title %}Home{% endblock %}
{% block sidebar %}
<ul id="sidebarUsers">
  {% if users %} {% for u in users %}
  <li class="chat-item" data-username="{{ u.username }}">
    <a class="chat-item__link" href="{% url 'room_with_user' u.username %}">
      <div class="chat-item__avatar">{{ u.username|first|upper }}</div>
      <div class="chat-item__meta">
        <div class="chat-item__top">
          <span class="chat-item__name">@{{ u.username }}</span>
          <span class="user-status"> (Offline)</span> {# Initial status, will be
          updated by JS #}
          <span class="chat-item__time"></span>
        </div>
        <div class="chat-item__last">Start a new chat</div>
      </div>
    </a>
  </li>
  {% endfor %} {% else %}
  <li class="chat-item--empty">No other users yet.</li>
  {% endif %}
</ul>
{% endblock %} {% block content %}
<div class="empty-state">
  <h2>Welcome to WhatsApp Clone</h2>
  <p>Click on a chat to start messaging or start a new one.</p>
</div>
{% endblock %}


--- chat\templates\chat\notifications.html ---
{% extends "chat/base.html" %}
{% block title %}Notifications{% endblock %}

{% block content %}
<div class="card">
  <h2>Notifications</h2>
  <ul>
    {% for log in logs %}
    <li style="margin:6px 0;">
      <strong>{{ log.sender }}</strong>
      {% if log.type == "chat" %}
      sent a message: “{{ log.message }}”
      {% elif log.type == "offer" %}
      started a call
      {% elif log.type == "answer" %}
      answered a call
      {% elif log.type == "ice" %}
      exchanged network info
      {% else %}
      {{ log.type }} {{ log.message }}
      {% endif %}
      <small style="color:#666;"> — {{ log.timestamp }}</small>
    </li>
    {% empty %}
    <li>No notifications yet.</li>
    {% endfor %}
  </ul>
</div>
{% endblock %}


--- chat\templates\chat\room.html ---
{% extends "chat/base.html" %} {% load static %} {% block title %}Chat with @{{
peer.username }} {% endblock %} {% block sidebar %}
<ul id="sidebarUsers">
  {% for u in users %}
  <li class="chat-item {% if u.username == peer.username %}is-active{% endif %}" data-username="{{ u.username }}">
    <a class="chat-item__link" href="{% url 'room_with_user' u.username %}">
      <div class="chat-item__avatar">{{ u.username|first|upper }}</div>
      <div class="chat-item__meta">
        <div class="chat-item__top">
          <span class="chat-item__name">@{{ u.username }}</span>
          <span class="user-status" data-user-status="{{ u.username }}">Offline</span>
          <span class="chat-item__time"></span>
        </div>
        <div class="chat-item__last"></div>
      </div>
    </a>
  </li>
  {% empty %}
  <li class="chat-item--empty">No other users yet.</li>
  {% endfor %}
</ul>
{% endblock %} {% block content %}
<div class="chat">
  <div class="chat__header">
    <div class="peer">
      <div class="peer__avatar">{{ peer.username|first|upper }}</div>
      <div class="peer__info">
        <div class="peer__name">@{{ peer.username }}</div>
        <div class="peer__status" id="chatHeaderStatus" data-peer-username="{{ peer.username }}">
          Offline
        </div>
        {# Initial status, will be updated by JS #}
      </div>
    </div>
    <div class="actions">
      <button id="btnStartCall" class="btn btn-ghost">
        <i class="fas fa-video"></i>
      </button>
      <button id="btnStartGroupCall" class="btn btn-ghost">
        <i class="fas fa-users"></i>
      </button>
    </div>
  </div>

  <div id="chatBox" class="chat__messages">
    {% for m in history %}
    <div class="msg {% if m.sender == request.user.username %}msg--me{% else %}msg--peer{% endif %}"
      data-message-id="{{ m.id }}">
      <div class="msg__avatar">{{ m.sender|first|upper }}</div>
      <div class="msg__bubble">
        <div class="msg__text">{{ m.message }}</div>
        <div class="msg__time">
          {{ m.timestamp|date:"P" }}
          {% if m.sender == request.user.username %}
          <span class="read-receipt" data-message-id="{{ m.id }}" data-read="{{ m.read|lower }}">
            {% if m.read %}
            <i class="fas fa-check-double"></i> {# Double tick for read #}
            {% else %}
            <i class="fas fa-check"></i> {# Single tick for sent #}
            {% endif %}
          </span>
          {% endif %}
        </div>
      </div>
    </div>
    {% empty %}
    <div class="chat__empty">
      <p>Say hello to @{{ peer.username }}!</p>
    </div>
    {% endfor %}
  </div>

  <div id="typingIndicator" class="typing-indicator" style="display: none">
    <span id="typingUsername"></span> is typing...
  </div>

  <form id="messageForm" class="composer">
    <button class="composer__btn"><i class="fas fa-smile"></i></button>
    <input id="messageInput" type="text" placeholder="Type a message" required class="composer__input" />
    <button class="composer__btn" type="submit">
      <i class="fas fa-paper-plane"></i>
    </button>
  </form>
</div>

<!-- Global Call Window (Floating/Draggable) -->
<div id="callWindow" class="call-window" style="display: none">
  <div class="call-header">
    <h4 id="callTitle">Video Call with @{{ peer.username }}</h4>
    <div class="call-header-actions">
      <button id="btnMinimizeMaximize" class="btn btn-ghost">
        <i class="fas fa-expand-alt"></i>
      </button>
      <button id="btnEndCall" class="btn btn-danger">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
  <div class="call-body">
    <div id="loadingIndicator" class="loading-indicator" style="display: none">
      <div class="spinner"></div>
      <p id="loadingText"></p>
    </div>
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="groupVideoContainer" class="group-video-container"></div>
    <video id="localVideo" autoplay playsinline muted></video>
    <div class="call-controls">
      <button id="btnToggleMic" class="btn">
        <i class="fas fa-microphone"></i>
      </button>
      <button id="btnToggleCamera" class="btn">
        <i class="fas fa-video"></i>
      </button>
      <button id="btnHangUp" class="btn btn-danger">
        <i class="fas fa-phone-slash"></i>
      </button>
    </div>
  </div>
</div>

<!-- Inline incoming call box (callee only) - Hidden by default, managed by JS -->
<div id="incomingCallBox" class="popup" style="display: none">
  <h4>Incoming Call</h4>
  <p id="incomingCallText"></p>
  <div class="actions">
    <button id="btnAcceptInline" class="btn btn-primary">
      <i class="fas fa-phone"></i> Accept
    </button>
    <button id="btnRejectInline" class="btn btn-danger">
      <i class="fas fa-phone-slash"></i> Reject
    </button>
  </div>
</div>

{% endblock %} {% block scripts %}
{{ webrtc_ice_servers|json_script:'webrtc_ice_servers' }}
<script>
  // Extend APP_CONTEXT with room-specific details
  window.APP_CONTEXT = window.APP_CONTEXT || {}; // Ensure APP_CONTEXT exists
  window.APP_CONTEXT.roomName = "{{ room_name }}";
  window.APP_CONTEXT.peerUsername = "{{ peer.username }}";
  window.APP_CONTEXT.iceServers = JSON.parse(
    document.getElementById("webrtc_ice_servers").textContent
  );
</script>
<script src="{% static 'js/chat.js' %}"></script>
<script src="{% static 'js/global-call-manager.js' %}"></script>
<script src="{% static 'js/webrtc.js' %}"></script>
<script>
  // Event listener for the hang up button in the call window
  document.getElementById("btnHangUp").addEventListener("click", () => {
    window.GlobalCallManager.endCall();
  });

  // Event listeners for inline incoming call box
  document.getElementById("btnAcceptInline").addEventListener("click", () => {
    window.GlobalCallManager.acceptCall();
  });

  document.getElementById("btnRejectInline").addEventListener("click", () => {
    window.GlobalCallManager.rejectCall();
  });

  // Update call title when call starts/changes
  window.addEventListener("globalCallStateChange", (event) => {
    const callState = event.detail;
    if (callState && callState.type === "active") {
      document.getElementById(
        "callTitle"
      ).innerText = `Video Call with @${callState.peer}`;
    } else {
      document.getElementById("callTitle").innerText = "Video Call";
    }
  });

  // Explicitly connect WebRTC WebSocket and initialize GlobalCallManager
  if (window.connectWebRTCWS) {
    window.connectWebRTCWS();
  } else {
    console.warn("window.connectWebRTCWS is not defined. WebRTC WebSocket might not connect.");
  }
  if (window.GlobalCallManager && window.GlobalCallManager.init) {
    window.GlobalCallManager.init();
  } else {
    console.warn("window.GlobalCallManager is not defined or init method is missing.");
  }
</script>
{% endblock %}


--- chat\templates\registration\login.html ---
{% extends "base_auth.html" %} {% load static %} {% block title %} Login {% endblock title %} {% block content %}
<h2>Login</h2>
<div class="form-wrapper">
  <form method="post">
    {% csrf_token %} {% if form.errors %}
    <div class="error-box">
      {% for field in form %} {% for error in field.errors %}
      <div>{{ error }}</div>
      {% endfor %} {% endfor %} {% for error in form.non_field_errors %}
      <div>{{ error }}</div>
      {% endfor %}
    </div>
    {% endif %}

    <input type="text" name="username" placeholder="Phone number or email" required />
    <input type="password" name="password" placeholder="Password" required />
    <button type="submit" name="login_submit">Login</button>
  </form>
</div>

{% endblock content %}


--- chat\templates\registration\signup.html ---
{% extends "base_auth.html" %} {% load static %} {% block content %}
<h2>Sign Up</h2>
<div class="form-wrapper">
  <form method="post">
    {% csrf_token %} {% if form.errors %}
    <div class="error-box">
      {% for field in form %} {% for error in field.errors %}
      <div>{{ error }}</div>
      {% endfor %} {% endfor %} {% for error in form.non_field_errors %}
      <div>{{ error }}</div>
      {% endfor %}
    </div>
    {% endif %} {% for field in form %}
    <div class="form-field">{{ field.label_tag }} {{ field }}</div>
    {% endfor %}
    <button type="submit">Sign Up</button>
  </form>
</div>
{% endblock content %}


--- static\css\app.css ---
/* WhatsApp-like Theme */

/* Variables */
:root {
    --whatsapp-green: #075e54;
    --whatsapp-light-green: #128c7e;
    --whatsapp-bg-dark: #0b141a;
    --whatsapp-bg-light: #111b21;
    --whatsapp-text-primary: #e9edef;
    --whatsapp-text-secondary: #8696a0;
    --whatsapp-border: #222e35;
    --whatsapp-bubble-me: #005c4b;
    --whatsapp-bubble-peer: #202c33;
    --whatsapp-icon: #aebac1;
    --status-online: #00a884;
    /* WhatsApp green for online */
    --status-offline: #8696a0;
    /* Grey for offline */

    /* Dark/Light Theme Variables */
    --bg-primary: var(--whatsapp-bg-dark);
    --bg-secondary: var(--whatsapp-bg-light);
    --text-primary: var(--whatsapp-text-primary);
    --text-secondary: var(--whatsapp-text-secondary);
    --border-color: var(--whatsapp-border);
    --header-bg: var(--whatsapp-green);
    --header-text: #fff;
    --sidebar-header-bg: var(--whatsapp-bubble-peer);
    --chat-bubble-me: var(--whatsapp-bubble-me);
    --chat-bubble-peer: var(--whatsapp-bubble-peer);
    --icon-color: var(--whatsapp-icon);
}

/* Light Theme Overrides */
body.light-theme {
    --bg-primary: #f0f2f5;
    --bg-secondary: #e0e2e5;
    --text-primary: #111b21;
    --text-secondary: #667781;
    --border-color: #d1d7db;
    --header-bg: #008069;
    --header-text: #fff;
    --sidebar-header-bg: #f0f2f5;
    --chat-bubble-me: #dcf8c6;
    --chat-bubble-peer: #fff;
    --icon-color: #54656f;
    --status-online: #008069;
    /* Lighter green for light theme online */
    --status-offline: #667781;
    /* Darker grey for light theme offline */
}

/* Reset-ish */
* {
    box-sizing: border-box;
}

html,
body {
    margin: 0;
    padding: 0;
    height: 100%;
    /* Ensure full viewport height */
    overflow: hidden;
    /* Prevent scrollbars on html/body */
}

body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    display: flex;
    /* Use flexbox for main layout */
    flex-direction: column;
    /* Stack topbar and workspace vertically */
    transition: background-color 0.3s ease, color 0.3s ease;
    /* Smooth theme transition */
}

/* Buttons */
.btn {
    border: 0;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s ease;
}

.btn-ghost {
    background: transparent;
    color: var(--whatsapp-icon);
}

.btn-ghost:hover {
    background: rgba(255, 255, 255, 0.1);
}

.btn-primary {
    background: var(--whatsapp-light-green);
    color: #fff;
}

.btn-primary:hover {
    filter: brightness(1.1);
}

.btn-danger {
    background: #e63d3d;
    color: #fff;
}

/* Topbar */
.topbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px;
    background: var(--header-bg);
    border-bottom: 1px solid var(--border-color);
    color: var(--header-text);
}

.brand {
    color: #fff;
    text-decoration: none;
    font-weight: 700;
    font-size: 18px;
}

.topbar__right {
    display: flex;
    gap: 15px;
    align-items: center;
}

.topbar__right span {
    color: rgba(255, 255, 255, 0.8);
}

.topbar__right .btn-ghost {
    color: #fff;
}

.whoami {
    opacity: .9;
}

.logout-form {
    display: inline;
}

/* Workspace (below topbar) */
.workspace {
    display: grid;
    grid-template-columns: 360px 1fr;
    flex-grow: 1;
    /* Allow workspace to take remaining height */
    margin-top: 52px;
    /* Space for fixed topbar */
    overflow: hidden;
    /* Prevent workspace from overflowing */
}

/* Sidebar Toggle Button for Mobile */
.sidebar-toggle {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: none;
    /* Hidden by default, shown on smaller screens */
    color: var(--icon-color);
    font-size: 20px;
}

@media (max-width: 768px) {
    .workspace {
        grid-template-columns: 1fr;
        /* Single column layout on mobile */
    }

    .pane--left {
        position: fixed;
        top: 52px;
        left: 0;
        bottom: 0;
        width: 100%;
        max-width: 360px;
        /* Limit sidebar width even on small screens */
        transform: translateX(-100%);
        transition: transform 0.3s ease-in-out;
        z-index: 999;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
    }

    .pane--left.is-open {
        transform: translateX(0);
    }

    .pane--right {
        width: 100%;
    }

    .sidebar-toggle {
        display: block;
        /* Show toggle button on mobile */
    }
}

/* Left pane */
.pane--left {
    background: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease-in-out;
    /* Smooth transition for sidebar */
}

.sidebar {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.sidebar__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: var(--sidebar-header-bg);
    border-bottom: 1px solid var(--border-color);
}

.sidebar__header .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #aebac1;
    display: grid;
    place-items: center;
    font-weight: 700;
    color: var(--whatsapp-bg-light);
}

.sidebar__header .actions {
    display: flex;
    gap: 15px;
}

.sidebar__header .actions .btn-ghost {
    font-size: 20px;
    padding: 5px;
    border-radius: 50%;
}

.sidebar__search {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border-color);
    background: var(--bg-secondary);
}

.sidebar__search input {
    width: 100%;
    padding: 8px 12px;
    border-radius: 20px;
    border: none;
    background: var(--chat-bubble-peer);
    color: var(--text-primary);
    outline: none;
    font-size: 14px;
}

.sidebar__search input::placeholder {
    color: var(--text-secondary);
}

.chat-list {
    list-style: none;
    margin: 0;
    padding: 0;
    overflow-y: auto;
    flex: 1;
}

.chat-item {
    border-bottom: 1px solid var(--border-color);
}

.chat-item--empty {
    padding: 16px;
    color: var(--text-secondary);
    text-align: center;
}

.chat-item__link {
    display: flex;
    /* Changed to flex for better alignment control */
    gap: 10px;
    padding: 12px 16px;
    text-decoration: none;
    color: inherit;
    align-items: center;
}

.chat-item.is-active,
.chat-item__link:hover {
    background: var(--chat-bubble-peer);
}

.chat-item__avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--icon-color);
    color: var(--bg-secondary);
    display: grid;
    place-items: center;
    font-weight: 700;
    font-size: 16px;
}

.chat-item__meta {
    overflow: hidden;
}

.chat-item__top {
    display: flex;
    justify-content: space-between;
    font-size: 15px;
    margin-bottom: 2px;
    align-items: center;
    /* Align items in the top row */
}

.chat-item__name {
    font-weight: 600;
    color: var(--text-primary);
}

.chat-item__time {
    color: var(--text-secondary);
    font-size: 12px;
}

.chat-item__last {
    color: var(--text-secondary);
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.chat-item__badge {
    align-self: center;
    background: var(--whatsapp-light-green);
    color: #fff;
    font-weight: 600;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 12px;
}

/* Right pane / Chat window */
.pane--right {
    background: var(--bg-primary);
    display: flex;
    flex-direction: column;
    height: calc(100vh - 52px);
    /* Full viewport height minus topbar */
    overflow: hidden;
    /* Prevent pane from overflowing */
}

.chat {
    flex: 1;
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    /* Take full height of its parent (pane--right) */
    overflow: hidden;
    /* Ensure chat container itself doesn't overflow */
}

.chat__header {
    height: 60px;
    flex: 0 0 60px;
    padding: 10px 16px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--chat-bubble-peer);
}

.peer {
    display: flex;
    gap: 10px;
    align-items: center;
}

.peer__avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--icon-color);
    color: var(--bg-secondary);
    display: grid;
    place-items: center;
    font-weight: 700;
    font-size: 16px;
}

.peer__name {
    font-weight: 600;
    color: var(--text-primary);
}

.peer__status {
    font-size: 12px;
    color: var(--text-secondary);
}

.chat__header .actions {
    display: flex;
    gap: 15px;
}

.chat__header .actions .btn-ghost {
    font-size: 20px;
    padding: 5px;
    border-radius: 50%;
}

.chat__messages {
    flex-grow: 1;
    overflow-y: auto;
    background-size: cover;
    background-position: center;
    padding: 16px 24px;
    display: flex;
    flex-direction: column;
    /* Messages stack vertically */
}

.msg {
    display: flex;
    margin-bottom: 12px;
    align-items: flex-end;
    gap: 8px;
    max-width: 75%;
    /* Limit message width */
    position: relative;
    width: 100%;
    /* Make msg take full width of its parent */
}

.msg--me {
    justify-content: flex-end;
    /* Push content to the right */
    flex-direction: row-reverse;
    /* Reverse order for sender's messages (avatar then bubble) */
    margin-left: auto;
    /* Ensure it pushes to the right */
    margin-right: 0;
}

.msg--peer {
    justify-content: flex-start;
    /* Keep content to the left */
    margin-right: auto;
    /* Ensure it stays to the left */
    margin-left: 0;
}

.msg__avatar {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background: var(--icon-color);
    color: var(--bg-secondary);
    display: grid;
    place-items: center;
    font-weight: 600;
    font-size: 14px;
    flex-shrink: 0;
}

.msg--me .msg__avatar {
    display: none !important;
    /* Force hide avatar for my messages */
}

.msg__bubble {
    max-width: 100%;
    padding: 10px 12px;
    border-radius: 10px;
    background: var(--chat-bubble-peer);
    /* Default for peer messages */
    color: var(--text-primary);
    position: relative;
    display: flex;
    flex-direction: column;
    word-break: break-word;
    box-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.13);
    /* Subtle shadow */
}

.msg--me .msg__bubble {
    background: var(--chat-bubble-me);
    /* Greenish for my messages */
    align-items: flex-end;
    /* Align text and time to the right for sender */
    border-bottom-right-radius: 2px;
    /* Pointed corner for sender */
}

.msg--peer .msg__bubble {
    background: var(--chat-bubble-peer);
    /* Greyish for peer messages */
    align-items: flex-start;
    /* Align text and time to the left for receiver */
    border-bottom-left-radius: 2px;
    /* Pointed corner for receiver */
}

.msg__text {
    white-space: pre-wrap;
    word-wrap: break-word;
    margin-bottom: 4px;
    line-height: 1.4;
}

.msg__time {
    font-size: 11px;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 5px;
    align-self: flex-end;
    /* Align time to the right within the bubble */
    margin-top: 2px;
    /* Small margin to separate from text */
}

/* Read Receipts */
.read-receipt {
    font-size: 10px;
    color: var(--text-secondary);
    margin-left: 5px;
}

.read-receipt .fa-check-double {
    color: var(--text-secondary);
    /* Default for delivered */
}

.read-receipt[data-read="true"] .fa-check-double {
    color: #34b7f1;
    /* Blue for seen */
}

/* Typing Indicator */
.typing-indicator {
    padding: 8px 16px;
    background: var(--chat-bubble-peer);
    color: var(--text-secondary);
    font-size: 14px;
    border-top: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 5px;
}

.typing-indicator span {
    font-weight: 600;
    color: var(--text-primary);
}

.chat__empty {
    color: var(--text-secondary);
    text-align: center;
    margin-top: 40px;
}

.composer {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 8px;
    padding: 8px 16px;
    background: var(--chat-bubble-peer);
    align-items: center;
    flex-shrink: 0;
}

.composer__btn {
    background: transparent;
    border: none;
    color: var(--icon-color);
    font-size: 24px;
    padding: 0;
    width: 40px;
    height: 40px;
    display: grid;
    place-items: center;
    border-radius: 50%;
}

.composer__btn:hover {
    background: rgba(255, 255, 255, 0.1);
}

.composer__input {
    border: none;
    background: var(--bg-secondary);
    color: var(--text-primary);
    padding: 10px 12px;
    border-radius: 20px;
    outline: none;
    font-size: 15px;
}

.composer__input::placeholder {
    color: var(--text-secondary);
}

/* Popups (WhatsApp style) */
.popup {
    position: fixed;
    right: 20px;
    background: var(--chat-bubble-peer);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 14px;
    box-shadow: 0 8px 22px rgba(0, 0, 0, .4);
    min-width: 280px;
    display: none;
    z-index: 2000;
    color: var(--text-primary);
}

#popup-message {
    bottom: 20px;
}

#popup-call {
    bottom: 120px;
}

.popup h4 {
    margin: 0 0 6px 0;
    font-size: 16px;
    color: var(--header-bg);
    /* Using header-bg for highlights */
}

.popup p {
    color: var(--text-secondary);
    margin: 0;
}

.popup .actions {
    margin-top: 15px;
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

/* Generic empty state */
.empty-state {
    place-self: center;
    text-align: center;
    color: var(--text-secondary);
    background: var(--chat-bubble-peer);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 24px;
    max-width: 400px;
}

/* Floating Call Window */
.call-window {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--bg-primary);
    border-radius: 12px;
    box-shadow: 0 8px 22px rgba(0, 0, 0, 0.4);
    overflow: hidden;
    z-index: 3000;
    display: none;
    min-width: 200px;
    min-height: 150px;
    max-width: 90vw;
    max-height: 90vh;
    transition: all 0.3s ease-in-out;
    border: 1px solid var(--border-color);
}

.call-window.minimized {
    width: 300px;
    height: 200px;
}

.call-window.maximized {
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    border-radius: 0;
}

.call-header {
    background: var(--chat-bubble-peer);
    color: var(--text-primary);
    padding: 8px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab;
    border-bottom: 1px solid var(--border-color);
}

.call-header-actions {
    display: flex;
    gap: 8px;
}

.call-header .btn {
    font-size: 14px;
    width: 28px;
    height: 28px;
    background: var(--bg-secondary);
    color: var(--icon-color);
    border-radius: 50%;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.call-header .btn:hover {
    background: var(--border-color);
}

.call-body {
    position: relative;
    width: 100%;
    height: calc(100% - 44px);
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.call-window.minimized .call-body {
    height: calc(100% - 44px);
}

.call-window.maximized .call-body {
    height: calc(100% - 44px);
}

#remoteVideo {
    width: 100%;
    height: 100%;
    object-fit: contain;
    background: #000;
}

#localVideo {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 120px;
    height: 90px;
    border-radius: 8px;
    object-fit: cover;
    border: 2px solid var(--whatsapp-light-green);
    /* Keep green border for local video */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    background: #000;
    transition: all 0.3s ease-in-out;
}

.call-window.maximized #localVideo {
    width: 180px;
    height: 135px;
}

.call-window.maximized #localVideo.hidden {
    display: none;
}

.call-controls {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    background: rgba(0, 0, 0, 0.6);
    padding: 8px 15px;
    border-radius: 25px;
    backdrop-filter: blur(5px);
}

.call-controls .btn {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
    font-size: 20px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s ease;
    padding: 0;
}

.call-controls .btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.call-controls .btn.active {
    background: var(--whatsapp-light-green);
    /* Keep green for active call controls */
}

.call-controls .btn.active:hover {
    background: #00c29e;
}

.call-controls .btn-danger {
    background: #e63d3d;
}

.call-controls .btn-danger:hover {
    background: #ff5c5c;
}


--- static\css\base_auth.css ---
body {
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: #f0f2f5;
    /* Light grey background */
    margin: 0;
    padding: 20px;
    /* Add some padding for mobile view */
    box-sizing: border-box;
}

.auth-container {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.1);
    width: 100%;
    max-width: 400px;
    /* Max width for desktop */
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.auth-header {
    display: flex;
    justify-content: space-around;
    background-color: #075e54;
    /* WhatsApp dark green */
    padding: 15px 0;
    border-bottom: 1px solid #ece5dd;
}

.auth-header button {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 18px;
    font-weight: 500;
    cursor: pointer;
    padding: 5px 10px;
    transition: color 0.3s ease;
}

.auth-header button.active {
    color: white;
    border-bottom: 2px solid white;
}

.auth-header button:hover:not(.active) {
    color: rgba(255, 255, 255, 0.9);
}

.auth-content {
    padding: 25px;
    background-color: #ece5dd;
    /* WhatsApp light background */
    flex-grow: 1;
}

h2 {
    text-align: center;
    color: #1f2d3d;
    /* Darker text for headings */
    margin-bottom: 25px;
    font-size: 24px;
}

.form-wrapper {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

input[type="text"],
input[type="email"],
input[type="password"] {
    width: 100%;
    padding: 12px 15px;
    border: 1px solid #ccc;
    border-radius: 20px;
    /* Rounded input fields */
    font-size: 16px;
    box-sizing: border-box;
    background-color: #fdfdfd;
    transition: border-color 0.2s ease;
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="password"]:focus {
    border-color: #25d366;
    /* WhatsApp green on focus */
    outline: none;
}

button[type="submit"] {
    width: 100%;
    padding: 12px 15px;
    background: #25d366;
    /* WhatsApp green button */
    color: white;
    border: none;
    border-radius: 20px;
    /* Rounded buttons */
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background-color 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

button[type="submit"]:hover {
    background: #1da851;
    /* Darker green on hover */
}

.error-box {
    background: #ffebee;
    /* Light red for errors */
    color: #d32f2f;
    /* Dark red text */
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 14px;
    margin-bottom: 15px;
    border: 1px solid #ef9a9a;
}

.error-box div {
    margin-bottom: 5px;
}

.error-box div:last-child {
    margin-bottom: 0;
}

.link-text {
    text-align: center;
    margin-top: 20px;
    font-size: 15px;
    color: #555;
}

.link-text a {
    color: #075e54;
    /* WhatsApp dark green for links */
    text-decoration: none;
    font-weight: 500;
}

.link-text a:hover {
    text-decoration: underline;
}

/* Mobile-first adjustments */
@media (max-width: 600px) {
    body {
        padding: 0;
        background: #075e54;
        /* Dark green background for full mobile screen */
    }

    .auth-container {
        border-radius: 0;
        box-shadow: none;
        height: 100vh;
        max-width: none;
    }

    .auth-content {
        padding: 20px;
    }

    h2 {
        font-size: 22px;
        margin-bottom: 20px;
    }

    input[type="text"],
    input[type="email"],
    input[type="password"],
    button[type="submit"] {
        padding: 15px;
        font-size: 17px;
    }
}


--- static\js\chat.js ---
(() => {
  const { me } = window.APP_CONTEXT; // Remove roomName from destructuring
  const showPopup = window.showPopup || ((id, text) => {});
  const hidePopup = window.hidePopup || ((id) => {});

  const chatBox = document.getElementById("chatBox");
  const messageInput = document.getElementById("messageInput");
  const messageForm = document.getElementById("messageForm");
  const sidebarUsers = document.getElementById("sidebarUsers");
  const chatHeaderStatus = document.getElementById("chatHeaderStatus");
  const typingIndicator = document.getElementById("typingIndicator");
  const typingUsernameSpan = document.getElementById("typingUsername");

  let ws = null; // Initialize ws to null
  let connected = false; // Add a flag to track connection status
  const onlineUsers = new Set();
  let typingTimeout = null;
  const TYPING_INDICATOR_TIMEOUT = 3000; // 3 seconds

  // Expose sendWS globally for webrtc.js to use
  window.sendChatWS = function (payload) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(payload));
    } else {
      console.warn("[chat.js] WebSocket not open. Message not sent:", payload);
    }
  };

  function appendMessage(
    sender,
    message,
    timestamp,
    messageId = null,
    readStatus = false,
    messageRoom = null // Added messageRoom parameter
  ) {
    const msgDiv = document.createElement("div");
    msgDiv.classList.add("msg");
    msgDiv.classList.add(sender === me ? "msg--me" : "msg--peer");
    if (messageId) {
      msgDiv.dataset.messageId = messageId;
    }

    const msgAvatar = document.createElement("div");
    msgAvatar.classList.add("msg__avatar");
    msgAvatar.innerText = sender.charAt(0).toUpperCase();
    msgDiv.appendChild(msgAvatar);

    const msgBubble = document.createElement("div");
    msgBubble.classList.add("msg__bubble");

    const msgText = document.createElement("div");
    msgText.classList.add("msg__text");
    msgText.innerText = message;

    const msgTime = document.createElement("div");
    msgTime.classList.add("msg__time");
    const date = new Date(timestamp);
    msgTime.innerText = date.toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true, // Ensure hh:mm a format
    });

    if (sender === me && messageId) {
      const readReceiptSpan = document.createElement("span");
      readReceiptSpan.classList.add("read-receipt");
      readReceiptSpan.dataset.messageId = messageId;
      // The `readStatus` from backend will be `false` for sent, `true` for delivered/read
      // We'll use CSS to differentiate between delivered and seen (blue)
      readReceiptSpan.dataset.read = readStatus.toString();
      readReceiptSpan.innerHTML = readStatus
        ? '<i class="fas fa-check-double"></i>' // Double tick for delivered/read
        : '<i class="fas fa-check"></i>'; // Single tick for sent
      msgTime.appendChild(readReceiptSpan);
    }

    msgBubble.appendChild(msgText);
    msgBubble.appendChild(msgTime);
    msgDiv.appendChild(msgBubble);
    chatBox.appendChild(msgDiv);

    chatBox.scrollTop = chatBox.scrollHeight; // Auto-scroll to bottom

    // If the message is from the peer, send a read receipt
    // Ensure read receipt is only sent if the message is for the current active room
    if (
      sender !== me &&
      messageId &&
      messageRoom === window.APP_CONTEXT.roomName // Use messageRoom parameter
    ) {
      window.sendChatWS({
        type: "read_receipt",
        message_id: messageId,
        room: window.APP_CONTEXT.roomName,
      });
    }
  }

  // Function to auto-scroll chat box to the bottom
  function scrollToBottom() {
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // This function will now be called by webrtc.js to set the shared WebSocket
  window.setSharedWebSocket = function (sharedWs) {
    ws = sharedWs;
    connected = true; // Assume connected when shared WS is set
    console.log("[chat.js] Shared WebSocket set and connected.");

    // Request online users list on connect
    window.sendChatWS({
      type: "get_online_users",
      room: window.APP_CONTEXT.roomName,
    });
  };

  // Expose a handler for webrtc.js to pass chat-specific messages to chat.js
  window.handleChatMessage = (data) => {
    console.log("[chat.js] Chat message received:", data); // Debugging
    const t = data.type;
    const from = data.from;
    const to = data.to;
    const messageRoom = data.room; // Get the room from the incoming message

    console.log(
      `[chat.js] Current room: ${window.APP_CONTEXT.roomName}, Message room: ${messageRoom}`
    ); // Added debug
    // Only process messages if they are for the current user AND for the current room
    if (to && to !== me) {
      console.log(
        `[chat.js] Message for user ${to} ignored (current user is ${me})`
      ); // Added debug
      return;
    }
    if (messageRoom && messageRoom !== window.APP_CONTEXT.roomName) {
      console.log(
        `[chat.js] Message for room ${messageRoom} ignored in current room ${window.APP_CONTEXT.roomName}`
      );
      return;
    }

    switch (t) {
      case "chat":
        // If a temporary message ID is provided, it means this is the server's confirmation
        if (data.temp_message_id) {
          const tempMsgDiv = chatBox.querySelector(
            `[data-message-id="${data.temp_message_id}"]`
          );
          if (tempMsgDiv) {
            tempMsgDiv.remove(); // Remove the temporary message
          }
        }

        // Check if the canonical message already exists to prevent duplicates
        if (
          data.message_id &&
          chatBox.querySelector(`[data-message-id="${data.message_id}"]`)
        ) {
          return; // Canonical message already rendered
        }

        // Append the canonical message from the server
        appendMessage(
          from,
          data.message,
          data.timestamp,
          data.message_id,
          data.read,
          messageRoom // Pass messageRoom
        );
        scrollToBottom(); // Scroll to bottom after appending new message
        break;

      case "user_status":
        handleUserStatus(data.username, data.is_online);
        break;

      case "online_users_list":
        updateOnlineUsersList(data.users);
        break;

      case "typing_indicator":
        handleTypingIndicator(data.username, data.is_typing);
        break;

      case "read_receipt":
        // This case handles the read receipt sent by the client to the server.
        // The server will then broadcast 'read_receipt_update' back to the sender.
        // No UI update needed here directly from this client-sent event.
        break;

      case "read_receipt_update": // New event type from consumer
        updateReadReceipt(data.message_id);
        break;

      case "missed_call":
        showPopup("popup-message", "Missed call from " + from);
        setTimeout(() => hidePopup("popup-message"), 4000);
        break;

      case "end_call":
        if (window.GlobalCallManager && window.GlobalCallManager.endCall) {
          window.GlobalCallManager.endCall();
          showPopup("popup-message", `${from} has ended the call.`);
          setTimeout(() => hidePopup("popup-message"), 4000);
        }
        break;

      default:
        // Pass other messages to webrtc.js if it has a handler
        if (window.handleWebRTCMessage) {
          window.handleWebRTCMessage(data);
        }
        break;
    }
  };

  // Handle message form submission
  if (messageForm) {
    messageForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const message = messageInput.value.trim();
      if (message) {
        // Temporarily append message with a client-generated ID to show immediately
        // This will be replaced/updated when the server echoes it back with a canonical ID
        const tempMessageId = `temp-${Date.now()}`;
        appendMessage(
          me,
          message,
          new Date().toISOString(),
          tempMessageId,
          false,
          window.APP_CONTEXT.roomName // Pass current room for temporary message
        );

        window.sendChatWS({
          // Use the exposed sendChatWS
          type: "chat",
          message: message,
          room: window.APP_CONTEXT.roomName, // Use window.APP_CONTEXT.roomName
          recipient: window.APP_CONTEXT.peerUsername, // Include the recipient
          temp_message_id: tempMessageId, // Send temp ID to server
        });
        messageInput.value = "";
        sendTypingStatus(false); // Stop typing after sending message
      }
    });
  }

  // Typing indicator logic
  if (messageInput) {
    messageInput.addEventListener("input", () => {
      sendTypingStatus(true);
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        sendTypingStatus(false);
      }, TYPING_INDICATOR_TIMEOUT);
    });
  }

  function sendTypingStatus(isTyping) {
    window.sendChatWS({
      // Use the exposed sendChatWS
      type: "typing",
      room: window.APP_CONTEXT.roomName, // Use window.APP_CONTEXT.roomName
      is_typing: isTyping,
    });
  }

  function handleTypingIndicator(username, isTyping) {
    if (username !== me) {
      if (isTyping) {
        typingUsernameSpan.innerText = username;
        typingIndicator.style.display = "block";
      } else {
        typingIndicator.style.display = "none";
      }
    }
  }

  function updateReadReceipt(messageId) {
    const readReceiptSpan = chatBox.querySelector(
      `.read-receipt[data-message-id="${messageId}"]`
    );
    if (readReceiptSpan) {
      readReceiptSpan.dataset.read = "true";
      readReceiptSpan.innerHTML = '<i class="fas fa-check-double"></i>';
    }
  }

  function handleUserStatus(username, isOnline) {
    console.log(
      `User status update: ${username} is ${isOnline ? "online" : "offline"}`
    ); // Debugging
    if (isOnline) {
      onlineUsers.add(username);
    } else {
      onlineUsers.delete(username);
    }
    updateSidebarUserStatus(username, isOnline);
    updateChatHeaderStatus();
  }

  function updateOnlineUsersList(users) {
    console.log("Online users list received:", users); // Debugging
    onlineUsers.clear();
    users.forEach((user) => onlineUsers.add(user));
    if (sidebarUsers) {
      Array.from(sidebarUsers.children).forEach((userDiv) => {
        const username = userDiv.dataset.username;
        if (username) {
          updateSidebarUserStatus(username, onlineUsers.has(username));
        }
      });
    }
    updateChatHeaderStatus();
  }

  function updateSidebarUserStatus(username, isOnline) {
    if (sidebarUsers) {
      const userDiv = sidebarUsers.querySelector(
        `[data-username="${username}"]`
      );
      if (userDiv) {
        let statusSpan = userDiv.querySelector(".user-status");
        if (!statusSpan) {
          statusSpan = document.createElement("span");
          statusSpan.classList.add("user-status");
          // Find the chat-item__top div to append the statusSpan
          const chatItemTop = userDiv.querySelector(".chat-item__top");
          if (chatItemTop) {
            chatItemTop.appendChild(statusSpan);
          } else {
            userDiv.appendChild(statusSpan); // Fallback if chat-item__top not found
          }
        }
        statusSpan.textContent = isOnline ? "Online" : "Offline";
        statusSpan.style.color = isOnline
          ? "var(--status-online)"
          : "var(--status-offline)";
        console.log(
          `Sidebar status for ${username}: ${statusSpan.textContent}`
        ); // Debugging
      }
    }
  }

  function updateChatHeaderStatus() {
    if (chatHeaderStatus) {
      const peerUsername = chatHeaderStatus.dataset.peerUsername;
      if (peerUsername) {
        const isOnline = onlineUsers.has(peerUsername);
        chatHeaderStatus.textContent = isOnline ? "Online" : "Offline";
        chatHeaderStatus.style.color = isOnline
          ? "var(--status-online)"
          : "var(--status-offline)";
        console.log(
          `Chat header status for ${peerUsername}: ${chatHeaderStatus.textContent}`
        ); // Debugging
      }
    }
  }

  window.getOnlineUsers = () => onlineUsers;

  // Call connectWS when the DOM is fully loaded
  // document.addEventListener("DOMContentLoaded", () => { // Removed: connectWS will be called explicitly from room.html
  //   if (!connected) {
  //     // Only connect if not already connected
  //     window.connectWS();
  //   }
  // });
})();



--- static\js\global-call-manager.js ---
// Global Call Manager - Handles video calls across chat switches
(() => {
  "use strict";

  // Global call state
  window.GlobalCallManager = {
    currentCall: null,
    incomingCall: null,
    localStream: null,
    remoteStream: null,
    isInitialized: false,
    currentPeerConnection: null, // For single call compatibility
    peerConnections: {}, // Store multiple peer connections for group calls
    currentWebSocket: null,
    isMinimized: true,
    isMicOn: true,
    isCamOn: true,

    // UI elements
    callWindow: null,
    localVideo: null,
    remoteVideo: null,
    btnMinimizeMaximize: null,
    btnEndCall: null,
    btnToggleMic: null,
    btnToggleCamera: null,
    btnHangUp: null, // New hang up button
    callTitle: null,

    // Initialize the global call manager
    init() {
      if (this.isInitialized) return;
      this.isInitialized = true;

      // Get UI references
      this.callWindow = document.getElementById("callWindow");
      this.localVideo = document.getElementById("localVideo");
      this.remoteVideo = document.getElementById("remoteVideo");
      this.btnMinimizeMaximize = document.getElementById("btnMinimizeMaximize");
      this.btnEndCall = document.getElementById("btnEndCall"); // This is the 'X' button
      this.btnToggleMic = document.getElementById("btnToggleMic");
      this.btnToggleCamera = document.getElementById("btnToggleCamera");
      this.btnHangUp = document.getElementById("btnHangUp"); // Reference the new hang up button
      this.callTitle = document.getElementById("callTitle");

      // Add event listeners
      if (this.btnMinimizeMaximize) {
        this.btnMinimizeMaximize.addEventListener("click", () =>
          this.toggleMinimizeMaximize()
        );
      }
      if (this.btnEndCall) {
        this.btnEndCall.addEventListener("click", () => this.endCall());
      }
      if (this.btnToggleMic) {
        this.btnToggleMic.addEventListener("click", () => this.toggleMic());
      }
      if (this.btnToggleCamera) {
        this.btnToggleCamera.addEventListener("click", () =>
          this.toggleCamera()
        );
      }
      if (this.btnHangUp) {
        this.btnHangUp.addEventListener("click", () => this.endCall());
      }

      // Make call window draggable
      this.makeDraggable(
        this.callWindow,
        this.callWindow.querySelector(".call-header")
      );

      // Listen for storage changes to sync across tabs/pages
      window.addEventListener("storage", (e) => {
        if (e.key === "activeCall") {
          this.handleCallStateChange(e.newValue);
        }
      });

      // Check for existing call state on page load
      this.restoreCallState();

      // Set up periodic cleanup of expired calls
      setInterval(() => this.cleanupExpiredCalls(), 5000);
    },

    // Set local video stream
    setLocalStream(stream) {
      this.localStream = stream;
      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }
      this.updateControlButtons();
    },

    // Set remote video stream
    setRemoteStream(stream) {
      this.remoteStream = stream;
      if (this.remoteVideo) {
        this.remoteVideo.srcObject = stream;
      }
    },

    // Show the call window
    showCallWindow() {
      if (this.callWindow) {
        this.callWindow.style.display = "block";
        // When showing, default to maximized for better initial experience
        this.callWindow.classList.remove("minimized");
        this.callWindow.classList.add("maximized");
        this.isMinimized = false; // Set to false as it's maximized
        this.updateMinimizeMaximizeIcon();
        this.updateControlButtons();
        this.updateLocalVideoVisibility(); // Ensure local video visibility is correct
      }
    },

    // Hide the call window
    hideCallWindow() {
      if (this.callWindow) {
        this.callWindow.style.display = "none";
        this.callWindow.classList.remove("minimized", "maximized");
      }
    },

    // Toggle minimize/maximize
    toggleMinimizeMaximize() {
      if (this.callWindow) {
        this.isMinimized = !this.isMinimized;
        this.callWindow.classList.toggle("minimized", this.isMinimized);
        this.callWindow.classList.toggle("maximized", !this.isMinimized);
        this.updateMinimizeMaximizeIcon();
        this.updateLocalVideoVisibility();
      }
    },

    // Update minimize/maximize icon
    updateMinimizeMaximizeIcon() {
      if (this.btnMinimizeMaximize) {
        const icon = this.btnMinimizeMaximize.querySelector("i");
        if (icon) {
          icon.classList.toggle("fa-expand-alt", this.isMinimized);
          icon.classList.toggle("fa-compress-alt", !this.isMinimized);
        }
      }
    },

    // Toggle microphone
    toggleMic() {
      if (this.localStream) {
        this.isMicOn = !this.isMicOn;
        this.localStream.getAudioTracks().forEach((track) => {
          track.enabled = this.isMicOn;
        });
        this.updateControlButtons();
      }
    },

    // Toggle camera
    toggleCamera() {
      if (this.localStream) {
        this.isCamOn = !this.isCamOn;
        this.localStream.getVideoTracks().forEach((track) => {
          track.enabled = this.isCamOn;
        });
        this.updateControlButtons();
        this.updateLocalVideoVisibility();
      }
    },

    // Update control button states
    updateControlButtons() {
      if (this.btnToggleMic) {
        this.btnToggleMic.classList.toggle("active", this.isMicOn);
        this.btnToggleMic.querySelector("i").className = this.isMicOn
          ? "fas fa-microphone"
          : "fas fa-microphone-slash";
      }
      if (this.btnToggleCamera) {
        this.btnToggleCamera.classList.toggle("active", this.isCamOn);
        this.btnToggleCamera.querySelector("i").className = this.isCamOn
          ? "fas fa-video"
          : "fas fa-video-slash";
      }
    },

    // Update local video visibility based on camera state and maximized mode
    updateLocalVideoVisibility() {
      if (this.localVideo) {
        const isMaximized = this.callWindow.classList.contains("maximized");
        if (isMaximized && !this.isCamOn) {
          this.localVideo.classList.add("hidden");
        } else {
          this.localVideo.classList.remove("hidden");
        }
      }
    },

    // Make an element draggable
    makeDraggable(element, handle) {
      let pos1 = 0,
        pos2 = 0,
        pos3 = 0,
        pos4 = 0;
      if (handle) {
        handle.onmousedown = dragMouseDown;
      } else {
        element.onmousedown = dragMouseDown;
      }

      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // get the mouse cursor position at startup:
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        // call a function whenever the cursor moves:
        document.onmousemove = elementDrag;
      }

      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // calculate the new cursor position:
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        // set the element's new position:
        element.style.top = element.offsetTop - pos2 + "px";
        element.style.left = element.offsetLeft - pos1 + "px";
      }

      function closeDragElement() {
        // stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
      }
    },

    // Save call state to localStorage
    saveCallState(callData) {
      const state = {
        ...callData,
        timestamp: Date.now(),
        currentPage: window.location.pathname,
      };
      localStorage.setItem("activeCall", JSON.stringify(state));
    },

    // Get call state from localStorage
    getCallState() {
      const stored = localStorage.getItem("activeCall");
      if (!stored) return null;

      try {
        const state = JSON.parse(stored);
        // Expire calls older than 2 minutes
        if (Date.now() - state.timestamp > 120000) {
          this.clearCallState();
          return null;
        }
        return state;
      } catch (e) {
        this.clearCallState();
        return null;
      }
    },

    // Clear call state
    clearCallState() {
      localStorage.removeItem("activeCall");
      this.currentCall = null;
      this.incomingCall = null;
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }
      this.remoteStream = null;
      if (this.localVideo) this.localVideo.srcObject = null;
      if (this.remoteVideo) this.remoteVideo.srcObject = null;
      this.hideCallWindow();

      // Clear all peer connections for group calls
      for (const peer in this.peerConnections) {
        if (this.peerConnections[peer]) {
          this.peerConnections[peer].close();
        }
      }
      this.peerConnections = {};
      this.currentPeerConnection = null; // Reset for single call compatibility
    },

    // Handle incoming call
    handleIncomingCall(callData) {
      this.incomingCall = callData;
      this.saveCallState({
        type: "incoming",
        from: callData.from,
        offer: callData.offer,
        room: callData.room || this.getCurrentRoom(),
        isGroup: callData.is_group_call || false, // Store if it's a group call
      });

      // Show global call popup
      this.showGlobalCallPopup(callData.from);
    },

    // Handle call acceptance
    async acceptCall() {
      if (!this.incomingCall) return;

      try {
        // Get user media
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true,
        });
        this.setLocalStream(stream);

        // Update call state
        this.currentCall = {
          type: "active",
          peer: this.incomingCall.from,
          room: this.incomingCall.room,
          isGroup: this.incomingCall.isGroup, // Preserve group call status
        };

        this.saveCallState(this.currentCall);
        this.hideGlobalCallPopup();
        this.showCallWindow(); // Show the floating window

        // Navigate to the correct room if not already there
        const expectedRoom = this.incomingCall.room;
        if (this.getCurrentRoom() !== expectedRoom) {
          const peerUsername = this.incomingCall.from;
          window.location.href = `/room/${peerUsername}/`;
          return;
        }

        // Trigger acceptance in the current room
        this.triggerRoomCallAcceptance();
      } catch (error) {
        console.error("Error accepting call:", error);
        this.rejectCall();
      }
    },

    // Handle call rejection
    rejectCall() {
      if (this.incomingCall) {
        // Send rejection through current WebSocket if available
        if (this.currentWebSocket) {
          this.currentWebSocket.send(
            JSON.stringify({
              type: "reject",
              to: this.incomingCall.from,
            })
          );
        }
      }

      this.clearCallState();
      this.hideGlobalCallPopup();
    },

    // Handle call end
    endCall() {
      if (this.currentCall) {
        // Send end call through current WebSocket if available
        if (this.currentWebSocket) {
          this.currentWebSocket.send(
            JSON.stringify({
              type: "end_call",
              to: this.currentCall.peer,
              is_group_call: this.currentCall.isGroup,
            })
          );
        }
      }

      // Stop local stream
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      // Close all peer connections (for group calls)
      for (const peer in this.peerConnections) {
        if (this.peerConnections[peer]) {
          this.peerConnections[peer].close();
        }
      }
      this.peerConnections = {};
      this.currentPeerConnection = null; // Reset for single call compatibility

      this.clearCallState();
      this.hideCallWindow();
    },

    // Show global call popup (for incoming calls)
    showGlobalCallPopup(callerName) {
      const popup = document.getElementById("popup-call");
      const popupText = document.getElementById("popup-call-text");
      if (popup && popupText) {
        popupText.innerText = `${callerName} is calling you...`;
        popup.style.display = "block";
      }
    },

    // Hide global call popup
    hideGlobalCallPopup() {
      const popup = document.getElementById("popup-call");
      if (popup) {
        popup.style.display = "none";
      }
    },

    // Restore call state on page load
    restoreCallState() {
      const state = this.getCallState();
      if (!state) return;

      if (state.type === "incoming") {
        this.incomingCall = state;
        this.showGlobalCallPopup(state.from);
      } else if (state.type === "active") {
        this.currentCall = state;
        this.showCallWindow(); // Show the floating window and maximize it
        // The room-specific code will handle active call restoration of streams
      }
    },

    // Handle call state changes from other tabs/pages
    handleCallStateChange(newStateJson) {
      if (!newStateJson) {
        this.hideGlobalCallPopup();
        this.clearCallState(); // Clear all state if no active call
        return;
      }

      try {
        const newState = JSON.parse(newStateJson);
        if (newState.type === "incoming") {
          this.incomingCall = newState;
          this.showGlobalCallPopup(newState.from);
        } else if (newState.type === "active") {
          this.currentCall = newState;
          this.hideGlobalCallPopup();
          this.showCallWindow();
          // Dispatch an event to the room-specific webrtc.js to handle stream restoration
          const event = new CustomEvent("globalCallStateRestored", {
            detail: newState,
          });
          window.dispatchEvent(event);
        } else {
          this.hideGlobalCallPopup();
          this.clearCallState();
        }
      } catch (e) {
        console.error("Error parsing call state:", e);
        this.clearCallState();
      }
    },

    // Get current room name from APP_CONTEXT
    getCurrentRoom() {
      return window.APP_CONTEXT.roomName || null;
    },

    // Get room name for a specific user
    getRoomNameForUser(username) {
      // This should match the Django view's _pair_room_name logic
      const currentUser = document.querySelector("strong")?.textContent || "";
      if (!currentUser || !username) return null;

      const users = [currentUser, username].sort();
      return `${users[0]}_${users[1]}`;
    },

    // Trigger call acceptance in the current room
    triggerRoomCallAcceptance() {
      // This will be called by room-specific code
      const event = new CustomEvent("globalCallAccepted", {
        detail: this.incomingCall,
      });
      window.dispatchEvent(event);
    },

    // Clean up expired calls
    cleanupExpiredCalls() {
      const state = this.getCallState();
      if (!state) return;

      // Remove calls older than 2 minutes
      if (Date.now() - state.timestamp > 120000) {
        this.endCall(); // Use endCall to ensure all resources are properly released
        this.hideGlobalCallPopup();
      }
    },
  };

  // Initialize when DOM is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      window.GlobalCallManager.init();
    });
  } else {
    window.GlobalCallManager.init();
  }
})();



--- static\js\webpush_serviceworker.js ---
self.addEventListener("push", function (event) {
  const data = event.data.json();
  const title = data.title || "VideoChat App";
  const options = {
    body: data.body || "You have a new notification.",
    icon: data.icon || "/static/img/icon-192x192.png", // Replace with your app icon
    badge: data.badge || "/static/img/badge-72x72.png", // Replace with your app badge
    data: {
      url: data.url || "/",
    },
  };
  event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener("notificationclick", function (event) {
  event.notification.close();
  event.waitUntil(clients.openWindow(event.notification.data.url));
});



--- static\js\webrtc.js ---
(() => {
  "use strict";
  console.log("[WebRTC] webrtc.js loaded.");

  const { me, roomName } = window.APP_CONTEXT; // Destructure 'me' and 'roomName' globally
  console.log("[WebRTC] APP_CONTEXT defined:", window.APP_CONTEXT);

  const chatWindow = document.getElementById("chatBox");
  const messageForm = document.getElementById("messageForm");
  const messageInput = document.getElementById("messageInput");
  const btnStartCall = document.getElementById("btnStartCall");
  const btnStartGroupCall = document.getElementById("btnStartGroupCall"); // New group call button
  const callWindow = document.getElementById("callWindow");
  const callTitle = document.getElementById("callTitle");
  const remoteVideo = document.getElementById("remoteVideo");
  const groupVideoContainer = document.getElementById("groupVideoContainer"); // New container for group videos
  const localVideo = document.getElementById("localVideo");
  const btnToggleMic = document.getElementById("btnToggleMic");
  const btnToggleCamera = document.getElementById("btnToggleCamera");
  const incomingCallBox = document.getElementById("incomingCallBox");
  const incomingCallText = document.getElementById("incomingCallText");
  const loadingIndicator = document.getElementById("loadingIndicator"); // Loading indicator
  const loadingText = document.getElementById("loadingText"); // Loading text

  const GlobalCallManager = window.GlobalCallManager;

  let ws; // Declare ws once here
  let localStream;
  let peerConnections = {}; // Use an object for multiple peer connections in group calls
  let isMuted = false;
  let isCameraOff = false;
  // let ringtone = new Audio("/static/audio/ringtone.mp3"); // Commented out to prevent 404

  function log(msg) {
    console.log("[WebRTC]", msg);
  }

  function showLoading(text) {
    if (loadingIndicator && loadingText) {
      loadingText.innerText = text;
      loadingIndicator.style.display = "flex";
    }
  }

  function hideLoading() {
    if (loadingIndicator) {
      loadingIndicator.style.display = "none";
    }
  }

  // Expose a handler for chat.js to pass messages to webrtc.js
  window.handleWebRTCMessage = async (data) => {
    const t = data.type;
    const from = data.from;
    const to = data.to;

    if (to && to !== me) return;

    switch (t) {
      case "offer":
        if (from === me) break;
        // ringtone.play(); // Commented out ringtone
        GlobalCallManager.handleIncomingCall({
          from: from,
          offer: data.offer,
          room: roomName,
          is_group_call: data.is_group_call || false, // Pass group call status
        });
        incomingCallText.innerText = `${from} is calling…`;
        incomingCallBox.style.display = "block";
        break;

      case "user_status":
        // This is handled by chat.js, but we might need to react to it for call management
        const peerUsername = roomName.split("_").find((user) => user !== me);
        if (
          data.username === peerUsername &&
          !data.is_online &&
          GlobalCallManager.currentCall &&
          GlobalCallManager.currentCall.type === "active"
        ) {
          GlobalCallManager.endCall();
          window.showPopup(
            "popup-message",
            `${data.username} went offline. Call ended.`
          );
          setTimeout(() => window.hidePopup("popup-message"), 4000);
        }
        break;

      case "answer":
        if (from === me) break;
        const pcAnswer = data.is_group_call
          ? peerConnections[from]
          : GlobalCallManager.currentPeerConnection;
        if (pcAnswer) {
          await pcAnswer.setRemoteDescription(
            new RTCSessionDescription(data.answer)
          );
        }
        break;

      case "ice":
        if (from === me) break;
        const pcIce = data.is_group_call
          ? peerConnections[from]
          : GlobalCallManager.currentPeerConnection;
        if (pcIce) {
          try {
            await pcIce.addIceCandidate(data.candidate);
          } catch (e) {
            console.error("Error adding ICE candidate:", e);
          }
        }
        break;

      case "end_call":
        GlobalCallManager.endCall();
        break;

      case "reject":
        GlobalCallManager.endCall();
        break;
    }
  };

  window.connectWebRTCWS = async function () {
    // Expose globally
    const roomName = window.APP_CONTEXT.roomName;
    if (!roomName || roomName === "undefined") {
      console.error(
        "[webrtc.js] Invalid roomName for WebRTC WebSocket connection:",
        roomName
      );
      return;
    }

    const token = localStorage.getItem("accessToken");
    let wsUrl =
      (location.protocol === "https:" ? "wss://" : "ws://") +
      location.host +
      "/ws/chat/" +
      roomName +
      "/";
    if (token) {
      wsUrl += `?token=${token}`;
    }
    console.log("[webrtc.js] Retrieved Token from localStorage:", token);
    console.log("[webrtc.js] WebRTC WebSocket URL:", wsUrl);
    ws = new WebSocket(wsUrl);
    GlobalCallManager.currentWebSocket = ws;

    ws.onopen = async () => {
      log("WebRTC WS open");
      sendWS({ type: "join" });
      await GlobalCallManager.restoreCallState();
      if (window.setSharedWebSocket) {
        window.setSharedWebSocket(ws);
      } else {
        console.warn(
          "[webrtc.js] window.setSharedWebSocket is not defined. Chat functionality might be limited."
        );
      }
    };

    ws.onmessage = async (evt) => {
      const data = JSON.parse(evt.data);
      console.log("[webrtc.js] WS message received:", data);
      if (
        data.type === "chat" ||
        data.type === "user_status" ||
        data.type === "online_users_list" ||
        data.type === "typing_indicator" ||
        data.type === "read_receipt"
      ) {
        if (window.handleChatMessage) {
          window.handleChatMessage(data);
        } else {
          console.warn(
            "[webrtc.js] window.handleChatMessage is not defined. Chat messages not handled."
          );
        }
      } else {
        window.handleWebRTCMessage(data);
      }
    };

    ws.onclose = () => {
      log("WebRTC WS closed. Reconnecting in 1.5 seconds...");
      setTimeout(window.connectWebRTCWS, 1500); // Use window.connectWebRTCWS for global access
    };

    ws.onerror = (err) => {
      console.error("WebRTC WebSocket error:", err);
      ws.close();
    };
  }; // End of window.connectWebRTCWS function

  function sendWS(payload) {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(payload));
    } else {
      console.warn(
        "[webrtc.js] WebSocket not open. Message not sent:",
        payload
      );
    }
  }

  async function startCall(
    peerUsername,
    existingOffer = null,
    isGroupCall = false
  ) {
    showLoading("Starting call...");
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      localVideo.srcObject = localStream;
      GlobalCallManager.setLocalStream(localStream);

      const pc = new RTCPeerConnection({
        iceServers: window.APP_CONTEXT.iceServers,
      });
      peerConnections[peerUsername] = pc;
      GlobalCallManager.currentPeerConnection = pc;

      localStream
        .getTracks()
        .forEach((track) => pc.addTrack(track, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          sendWS({
            type: "ice",
            to: peerUsername,
            candidate: e.candidate,
            is_group_call: isGroupCall,
          });
        }
      };

      pc.ontrack = (e) => {
        if (isGroupCall) {
          const videoElement = document.createElement("video");
          videoElement.autoplay = true;
          videoElement.playsInline = true;
          videoElement.srcObject = e.streams[0];
          videoElement.dataset.peer = peerUsername;
          groupVideoContainer.appendChild(videoElement);
        } else {
          remoteVideo.srcObject = e.streams[0];
          GlobalCallManager.setRemoteStream(e.streams[0]);
        }
      };

      if (existingOffer) {
        await pc.setRemoteDescription(new RTCSessionDescription(existingOffer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendWS({
          type: "answer",
          to: peerUsername,
          answer,
          is_group_call: isGroupCall,
        });
      } else {
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,
        });
        await pc.setLocalDescription(offer);
        sendWS({
          type: "offer",
          to: peerUsername,
          offer,
          room: roomName,
          is_group_call: isGroupCall,
        });
      }

      GlobalCallManager.currentCall = {
        type: "active",
        peer: peerUsername,
        room: roomName,
        isGroup: isGroupCall,
      };
      GlobalCallManager.saveCallState(GlobalCallManager.currentCall);
      GlobalCallManager.showCallWindow();
      updateCallUI();
      hideLoading();
    } catch (error) {
      console.error("Error starting call:", error);
      alert(
        "Failed to start call. Please check camera/microphone permissions."
      );
      GlobalCallManager.endCall();
      hideLoading();
    }
  }

  async function restoreCallState() {
    const savedCallState = GlobalCallManager.getCallState();
    if (
      savedCallState &&
      savedCallState.room === roomName &&
      savedCallState.type === "active"
    ) {
      log("Restoring call state...");
      const peerUsername = savedCallState.peer;
      await startCall(peerUsername, null, savedCallState.isGroup);
    }
  }

  function updateCallUI() {
    const currentCall = GlobalCallManager.currentCall;
    if (currentCall && currentCall.isGroup) {
      callTitle.innerText = `Group Call in ${currentCall.room}`;
      remoteVideo.style.display = "none";
      groupVideoContainer.style.display = "flex";
    } else {
      const peerUsername = roomName.split("_").find((user) => user !== me);
      callTitle.innerText = `Video Call with @${peerUsername}`;
      remoteVideo.style.display = "block";
      groupVideoContainer.style.display = "none";
    }

    if (btnToggleMic) {
      btnToggleMic.classList.toggle("active", !isMuted);
      btnToggleMic.querySelector("i").className = isMuted
        ? "fas fa-microphone-slash"
        : "fas fa-microphone";
    }

    if (btnToggleCamera) {
      btnToggleCamera.classList.toggle("active", !isCameraOff);
      btnToggleCamera.querySelector("i").className = isCameraOff
        ? "fas fa-video-slash"
        : "fas fa-video";
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // Event listener for starting a call
    if (btnStartCall) {
      btnStartCall.addEventListener("click", async () => {
        console.log("[WebRTC] btnStartCall clicked!");
        const peerUsername = roomName.split("_").find((user) => user !== me);
        if (!peerUsername) {
          console.error(
            "Cannot start call: No peer username found in roomName."
          );
          return;
        }
        console.log("[WebRTC] Peer username:", peerUsername);

        if (
          window.getOnlineUsers &&
          !window.getOnlineUsers().has(peerUsername)
        ) {
          window.showPopup(
            "popup-message",
            `${peerUsername} is currently offline.`
          );
          setTimeout(() => window.hidePopup("popup-message"), 4000);
          return;
        }

        await startCall(peerUsername);
      });
    }

    // Event listener for starting a group call
    if (btnStartGroupCall) {
      btnStartGroupCall.addEventListener("click", async () => {
        console.log("[WebRTC] btnStartGroupCall clicked!");
        const onlinePeers = Array.from(window.getOnlineUsers()).filter(
          (user) => user !== me
        );

        if (onlinePeers.length === 0) {
          window.showPopup(
            "popup-message",
            "No other users online for a group call."
          );
          setTimeout(() => window.hidePopup("popup-message"), 4000);
          return;
        }

        showLoading("Starting group call...");
        for (const peer of onlinePeers) {
          await startCall(peer, null, true);
        }
        hideLoading();
      });
    }

    // Mute/Unmute Mic
    if (btnToggleMic) {
      btnToggleMic.addEventListener("click", () => {
        if (localStream) {
          localStream.getAudioTracks().forEach((track) => {
            track.enabled = !track.enabled;
            isMuted = !track.enabled;
          });
          updateCallUI();
        }
      });
    }

    // Toggle Camera
    if (btnToggleCamera) {
      btnToggleCamera.addEventListener("click", () => {
        if (localStream) {
          localStream.getVideoTracks().forEach((track) => {
            track.enabled = !track.enabled;
            isCameraOff = !track.enabled;
          });
          updateCallUI();
        }
      });
    }

    // Listen for global call acceptance from GlobalCallManager (when navigating to a room)
    window.addEventListener("globalCallAccepted", async (event) => {
      const incomingCallData = event.detail;
      if (!incomingCallData) return;

      // ringtone.pause(); // Commented out ringtone
      // ringtone.currentTime = 0; // Commented out ringtone

      const peerUsername = incomingCallData.from;
      await startCall(
        peerUsername,
        incomingCallData.offer,
        incomingCallData.isGroup
      );
      GlobalCallManager.hideGlobalCallPopup();
      incomingCallBox.style.display = "none";
    });

    // Listen for global call rejection from GlobalCallManager
    window.addEventListener("globalCallRejected", () => {
      // ringtone.pause(); // Commented out ringtone
      // ringtone.currentTime = 0; // Commented out ringtone
      incomingCallBox.style.display = "none";
    });

    // Initialize GlobalCallManager here, after APP_CONTEXT is defined
    window.GlobalCallManager.init();
  });
})();



--- videochat\asgi.py ---
import os
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack # Import AuthMiddlewareStack
from channels.security.websocket import AllowedHostsOriginValidator

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "videochat.settings")

django_asgi_app = get_asgi_application()

from chat.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AllowedHostsOriginValidator(
        AuthMiddlewareStack( # Use AuthMiddlewareStack for session authentication
            URLRouter(websocket_urlpatterns)
        )
    ),
})



--- videochat\settings.py ---
from pathlib import Path
from pymongo import MongoClient
from dotenv import load_dotenv
import os

# Load environment variables from .env file
load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv("SECRET_KEY", "fallback-key")
DEBUG = os.getenv("DEBUG", "True") == "True"
ALLOWED_HOSTS = []

INSTALLED_APPS = [
    'daphne',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework_simplejwt',
    'chat',
    'accounts',
    'django_ratelimit',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django_ratelimit.middleware.RatelimitMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / "templates"],
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
            'loaders': [
                'django.template.loaders.filesystem.Loader',
                'django.template.loaders.app_directories.Loader',
            ],
        },
    },
]

ROOT_URLCONF = 'videochat.urls'
ASGI_APPLICATION = 'videochat.asgi.application'

CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [os.getenv("REDIS_URL", "redis://localhost:6379/0")],
        },
    },
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ),
}

from datetime import timedelta

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
    'JTI_CLAIM': 'jti',
    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
}

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

STATIC_URL = 'static/'

LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/accounts/login/'

# --- MongoDB from .env ---
MONGO_URI = os.getenv("MONGO_URI", "")
MONGO_DB_NAME = os.getenv("MONGO_DB_NAME", "")

mongo_client = None
mongo_db = None

if MONGO_URI and MONGO_DB_NAME:
    try:
        mongo_client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
        mongo_client.server_info()  # force connection test
        mongo_db = mongo_client[MONGO_DB_NAME]
    except Exception as e:
        print(f"[MongoDB] Connection failed: {e}")
        mongo_db = None

STATIC_URL = '/static/'
STATICFILES_DIRS = [
    BASE_DIR / "static"
]

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / "media"

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
]

AUTH_USER_MODEL = 'accounts.CustomUser'

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' # For development, prints emails to console
# For production, use a real email backend like:
# EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
# EMAIL_HOST = 'smtp.sendgrid.net'
# EMAIL_PORT = 587
# EMAIL_USE_TLS = True
# EMAIL_HOST_USER = os.getenv('SENDGRID_USERNAME')
# EMAIL_HOST_PASSWORD = os.getenv('SENDGRID_PASSWORD')
# DEFAULT_FROM_EMAIL = 'your_email@example.com'

# WebRTC ICE Servers (STUN/TURN)
WEBRTC_ICE_SERVERS = [
    {"urls": "stun:stun.l.google.com:19302"},
    {"urls": "stun:stun1.l.google.com:19302"},
    # Add TURN servers here if needed, e.g.:
    # {"urls": "turn:your_turn_server.com:3478", "username": "user", "credential": "password"},
]

# Cache for django-ratelimit
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": os.getenv("REDIS_URL", "redis://127.0.0.1:6379/1"),
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}

# WebPush VAPID keys
VAPID_PUBLIC_KEY = os.getenv("VAPID_PUBLIC_KEY", "BP_YOUR_PUBLIC_KEY_HERE")
VAPID_PRIVATE_KEY = os.getenv("VAPID_PRIVATE_KEY", "YOUR_PRIVATE_KEY_HERE")
VAPID_ADMIN_EMAIL = os.getenv("VAPID_ADMIN_EMAIL", "mailto:your_email@example.com")



--- videochat\urls.py ---
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('django.contrib.auth.urls')),
    path('accounts/', include('accounts.urls')),
    path('', include('chat.urls')),   # home, notifications, rooms live here
]

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)



--- videochat\__init__.py ---

